'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCompilerHostFromProjectRoot = exports.createCompilerHostFromConfigFile = exports.createCompilerHostFromBabelRc = undefined;

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

/**
 * Creates a compiler host from a .babelrc file. This method is usually called
 * from {@link createCompilerHostFromProjectRoot} instead of used directly.
 *
 * @param  {string} file  The path to a .babelrc file
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */

var createCompilerHostFromBabelRc = exports.createCompilerHostFromBabelRc = function () {
  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(file) {
    var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var info, ourEnv;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.t0 = JSON;
            _context.next = 3;
            return _promise.pfs.readFile(file, 'utf8');

          case 3:
            _context.t1 = _context.sent;
            info = _context.t0.parse.call(_context.t0, _context.t1);


            // package.json
            if ('babel' in info) {
              info = info.babel;
            }

            if ('env' in info) {
              ourEnv = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';

              info = info.env[ourEnv];
            }

            // Are we still package.json (i.e. is there no babel info whatsoever?)

            if (!('name' in info && 'version' in info)) {
              _context.next = 9;
              break;
            }

            return _context.abrupt('return', createCompilerHostFromConfiguration({
              appRoot: _path2.default.dirname(file),
              options: getDefaultConfiguration(),
              rootCacheDir: rootCacheDir
            }));

          case 9:
            return _context.abrupt('return', createCompilerHostFromConfiguration({
              appRoot: _path2.default.dirname(file),
              options: {
                'application/javascript': info
              },
              rootCacheDir: rootCacheDir
            }));

          case 10:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return function createCompilerHostFromBabelRc(_x4) {
    return ref.apply(this, arguments);
  };
}();

/**
 * Creates a compiler host from a .compilerc file. This method is usually called
 * from {@link createCompilerHostFromProjectRoot} instead of used directly.
 *
 * @param  {string} file  The path to a .compilerc file
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */


var createCompilerHostFromConfigFile = exports.createCompilerHostFromConfigFile = function () {
  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(file) {
    var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var info, ourEnv;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.t0 = JSON;
            _context2.next = 3;
            return _promise.pfs.readFile(file, 'utf8');

          case 3:
            _context2.t1 = _context2.sent;
            info = _context2.t0.parse.call(_context2.t0, _context2.t1);


            if ('env' in info) {
              ourEnv = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';

              info = info.env[ourEnv];
            }

            return _context2.abrupt('return', createCompilerHostFromConfiguration({
              appRoot: _path2.default.dirname(file),
              options: info,
              rootCacheDir: rootCacheDir
            }));

          case 7:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return function createCompilerHostFromConfigFile(_x6) {
    return ref.apply(this, arguments);
  };
}();

/**
 * Creates a configured {@link CompilerHost} instance from the project root
 * directory. This method first searches for a .compilerc, then falls back to the
 * default locations for Babel configuration info. If neither are found, defaults
 * to standard settings
 *
 * @param  {string} rootDir  The root application directory (i.e. the directory
 *                           that has the app's package.json)
 *
 * @param  {string} rootCacheDir (optional)  The directory to use as a cache.
 *
 * @return {Promise<CompilerHost>}  A set-up compiler host
 */


var createCompilerHostFromProjectRoot = exports.createCompilerHostFromProjectRoot = function () {
  var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(rootDir) {
    var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var compilerc, babelrc;
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            compilerc = _path2.default.join(rootDir, '.compilerc');

            if (!statSyncNoException(compilerc)) {
              _context3.next = 6;
              break;
            }

            d('Found a .compilerc at ' + compilerc + ', using it');
            _context3.next = 5;
            return createCompilerHostFromConfigFile(compilerc, rootCacheDir);

          case 5:
            return _context3.abrupt('return', _context3.sent);

          case 6:
            babelrc = _path2.default.join(rootDir, '.babelrc');

            if (!statSyncNoException(babelrc)) {
              _context3.next = 12;
              break;
            }

            d('Found a .babelrc at ' + babelrc + ', using it');
            _context3.next = 11;
            return createCompilerHostFromBabelRc(babelrc, rootCacheDir);

          case 11:
            return _context3.abrupt('return', _context3.sent);

          case 12:

            d('Using package.json or default parameters at ' + rootDir);
            _context3.next = 15;
            return createCompilerHostFromBabelRc(_path2.default.join(rootDir, 'package.json'), rootCacheDir);

          case 15:
            return _context3.abrupt('return', _context3.sent);

          case 16:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return function createCompilerHostFromProjectRoot(_x8) {
    return ref.apply(this, arguments);
  };
}();

exports.initializeGlobalHooks = initializeGlobalHooks;
exports.init = init;
exports.createCompilerHostFromConfiguration = createCompilerHostFromConfiguration;
exports.createCompilerHostFromBabelRcSync = createCompilerHostFromBabelRcSync;
exports.createCompilerHostFromConfigFileSync = createCompilerHostFromConfigFileSync;
exports.createCompilerHostFromProjectRootSync = createCompilerHostFromProjectRootSync;
exports.calculateDefaultCompileCacheDirectory = calculateDefaultCompileCacheDirectory;
exports.getDefaultConfiguration = getDefaultConfiguration;
exports.createCompilers = createCompilers;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _promise = require('./promise');

var _fileChangeCache = require('./file-change-cache');

var _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);

var _compilerHost = require('./compiler-host');

var _compilerHost2 = _interopRequireDefault(_compilerHost);

var _requireHook = require('./require-hook');

var _requireHook2 = _interopRequireDefault(_requireHook);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var d = require('debug')('electron-compile:config-parser');

// NB: We intentionally delay-load this so that in production, you can create
// cache-only versions of these compilers
var allCompilerClasses = null;

function statSyncNoException(fsPath) {
  if ('statSyncNoException' in _fs2.default) {
    return _fs2.default.statSyncNoException(fsPath);
  }

  try {
    return _fs2.default.statSync(fsPath);
  } catch (e) {
    return null;
  }
}

/**
 * Initialize the global hooks (protocol hook for file:, node.js hook)
 * independent of initializing the compiler. This method is usually called by
 * init instead of directly
 *
 * @param {CompilerHost} compilerHost  The compiler host to use.
 *
 */
function initializeGlobalHooks(compilerHost) {
  var globalVar = global || window;
  globalVar.globalCompilerHost = compilerHost;

  (0, _requireHook2.default)(compilerHost);

  if ('type' in process && process.type === 'browser') {
    (function () {
      var _require = require('electron');

      var app = _require.app;

      var _require2 = require('./protocol-hook');

      var initializeProtocolHook = _require2.initializeProtocolHook;


      var protoify = function protoify() {
        initializeProtocolHook(compilerHost);
      };
      if (app.isReady()) {
        protoify();
      } else {
        app.on('ready', protoify);
      }
    })();
  }
}

/**
 * Initialize electron-compile and set it up, either for development or
 * production use. This is almost always the only method you need to use in order
 * to use electron-compile.
 *
 * @param  {string} appRoot  The top-level directory for your application (i.e.
 *                           the one which has your package.json).
 *
 * @param  {string} mainModule  The module to require in, relative to the module
 *                              calling init, that will start your app. Write this
 *                              as if you were writing a require call from here.
 *
 * @param  {bool} productionMode   If explicitly True/False, will set read-only
 *                                 mode to be disabled/enabled. If not, we'll
 *                                 guess based on the presence of a production
 *                                 cache.
 *
 * @param  {string} cacheDir  If not passed in, read-only will look in
 *                            `appRoot/.cache` and dev mode will compile to a
 *                            temporary directory. If it is passed in, both modes
 *                            will cache to/from `appRoot/{cacheDir}`
 */
function init(appRoot, mainModule) {
  var productionMode = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
  var cacheDir = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

  var compilerHost = null;
  var rootCacheDir = _path2.default.join(appRoot, cacheDir || '.cache');

  if (productionMode === null) {
    productionMode = !!statSyncNoException(rootCacheDir);
  }

  if (productionMode) {
    compilerHost = _compilerHost2.default.createReadonlyFromConfigurationSync(rootCacheDir, appRoot);
  } else {
    // if cacheDir was passed in, pass it along. Otherwise, default to a tempdir.
    if (cacheDir) {
      compilerHost = createCompilerHostFromProjectRootSync(appRoot, rootCacheDir);
    } else {
      compilerHost = createCompilerHostFromProjectRootSync(appRoot);
    }
  }

  initializeGlobalHooks(compilerHost);
  require.main.require(mainModule);
}

/**
 * Creates a {@link CompilerHost} with the given information. This method is
 * usually called by {@link createCompilerHostFromProjectRoot}.
 *
 * @private
 */
function createCompilerHostFromConfiguration(info) {
  var compilers = createCompilers();
  var rootCacheDir = info.rootCacheDir || calculateDefaultCompileCacheDirectory();

  d('Creating CompilerHost: ' + (0, _stringify2.default)(info) + ', rootCacheDir = ' + rootCacheDir);
  var fileChangeCache = new _fileChangeCache2.default(info.appRoot);
  var ret = new _compilerHost2.default(rootCacheDir, compilers, fileChangeCache, false, compilers['text/plain']);

  _lodash2.default.each((0, _keys2.default)(info.options || {}), function (x) {
    var opts = info.options[x];
    if (!(x in compilers)) {
      throw new Error('Found compiler settings for missing compiler: ' + x);
    }

    d('Setting options for ' + x + ': ' + (0, _stringify2.default)(opts));
    compilers[x].compilerOptions = opts;
  });

  // NB: It's super important that we guarantee that the configuration is saved
  // out, because we'll need to re-read it in the renderer process
  d('Created compiler host with options: ' + (0, _stringify2.default)(info));
  ret.saveConfigurationSync();
  return ret;
}function createCompilerHostFromBabelRcSync(file) {
  var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  var info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));

  // package.json
  if ('babel' in info) {
    info = info.babel;
  }

  if ('env' in info) {
    var ourEnv = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';
    info = info.env[ourEnv];
  }

  // Are we still package.json (i.e. is there no babel info whatsoever?)
  if ('name' in info && 'version' in info) {
    return createCompilerHostFromConfiguration({
      appRoot: _path2.default.dirname(file),
      options: getDefaultConfiguration(),
      rootCacheDir: rootCacheDir
    });
  }

  return createCompilerHostFromConfiguration({
    appRoot: _path2.default.dirname(file),
    options: {
      'application/javascript': info
    },
    rootCacheDir: rootCacheDir
  });
}

function createCompilerHostFromConfigFileSync(file) {
  var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  var info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));

  if ('env' in info) {
    var ourEnv = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';
    info = info.env[ourEnv];
  }

  return createCompilerHostFromConfiguration({
    appRoot: _path2.default.dirname(file),
    options: info,
    rootCacheDir: rootCacheDir
  });
}

function createCompilerHostFromProjectRootSync(rootDir) {
  var rootCacheDir = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  var compilerc = _path2.default.join(rootDir, '.compilerc');
  if (statSyncNoException(compilerc)) {
    d('Found a .compilerc at ' + compilerc + ', using it');
    return createCompilerHostFromConfigFileSync(compilerc, rootCacheDir);
  }

  var babelrc = _path2.default.join(rootDir, '.babelrc');
  if (statSyncNoException(babelrc)) {
    d('Found a .babelrc at ' + babelrc + ', using it');
    return createCompilerHostFromBabelRcSync(babelrc, rootCacheDir);
  }

  d('Using package.json or default parameters at ' + rootDir);
  return createCompilerHostFromBabelRcSync(_path2.default.join(rootDir, 'package.json'), rootCacheDir);
}

/**
 * Returns what electron-compile would use as a default rootCacheDir. Usually only
 * used for debugging purposes
 *
 * @return {string}  A path that may or may not exist where electron-compile would
 *                   set up a development mode cache.
 */
function calculateDefaultCompileCacheDirectory() {
  var tmpDir = process.env.TEMP || process.env.TMPDIR || '/tmp';
  var hash = require('crypto').createHash('md5').update(process.execPath).digest('hex');

  var cacheDir = _path2.default.join(tmpDir, 'compileCache_' + hash);
  _mkdirp2.default.sync(cacheDir);

  d('Using default cache directory: ' + cacheDir);
  return cacheDir;
}

/**
 * Returns the default .configrc if no configuration information can be found.
 *
 * @return {Object}  A list of default config settings for electron-compiler.
 */
function getDefaultConfiguration() {
  return {
    'application/javascript': {
      "presets": ["stage-0", "es2015", "react"],
      "sourceMaps": "inline"
    }
  };
}

/**
 * Allows you to create new instances of all compilers that are supported by
 * electron-compile and use them directly. Currently supports Babel, CoffeeScript,
 * TypeScript, Less, and Jade.
 *
 * @return {Object}  An Object whose Keys are MIME types, and whose values
 * are instances of @{link CompilerBase}.
 */
function createCompilers() {
  if (!allCompilerClasses) {
    // First we want to see if electron-compilers itself has been installed with
    // devDependencies. If that's not the case, check to see if
    // electron-compilers is installed as a peer dependency (probably as a
    // devDependency of the root project).
    var locations = ['electron-compilers', '../../electron-compilers'];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(locations), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var location = _step.value;

        try {
          allCompilerClasses = require(location);
        } catch (e) {
          // Yolo
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!allCompilerClasses) {
      throw new Error("Electron compilers not found but were requested to be loaded");
    }
  }

  // NB: Note that this code is carefully set up so that InlineHtmlCompiler
  // (i.e. classes with `createFromCompilers`) initially get an empty object,
  // but will have a reference to the final result of what we return, which
  // resolves the circular dependency we'd otherwise have here.
  var ret = {};
  var instantiatedClasses = _lodash2.default.map(allCompilerClasses, function (Klass) {
    if ('createFromCompilers' in Klass) {
      return Klass.createFromCompilers(ret);
    } else {
      return new Klass();
    }
  });

  _lodash2.default.reduce(instantiatedClasses, function (acc, x) {
    var Klass = (0, _getPrototypeOf2.default)(x).constructor;

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator3.default)(Klass.getInputMimeTypes()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var type = _step2.value;
        acc[type] = x;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return acc;
  }, ret);

  return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb25maWctcGFyc2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVBaUpPLGlCQUE2QyxJQUE3QztBQUFBLFFBQW1ELFlBQW5ELHlEQUFnRSxJQUFoRTtBQUFBLFFBQ0QsSUFEQyxFQVNDLE1BVEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBCQUNNLElBRE47QUFBQTtBQUFBLG1CQUN1QixhQUFJLFFBQUosQ0FBYSxJQUFiLEVBQW1CLE1BQW5CLENBRHZCOztBQUFBO0FBQUE7QUFDRCxnQkFEQyxlQUNXLEtBRFg7Ozs7QUFJTCxnQkFBSSxXQUFXLElBQWYsRUFBcUI7QUFDbkIscUJBQU8sS0FBSyxLQUFaO0FBQ0Q7O0FBRUQsZ0JBQUksU0FBUyxJQUFiLEVBQW1CO0FBQ2Isb0JBRGEsR0FDSixRQUFRLEdBQVIsQ0FBWSxTQUFaLElBQXlCLFFBQVEsR0FBUixDQUFZLFFBQXJDLElBQWlELGFBRDdDOztBQUVqQixxQkFBTyxLQUFLLEdBQUwsQ0FBUyxNQUFULENBQVA7QUFDRDs7OztBQVhJLGtCQWNELFVBQVUsSUFBVixJQUFrQixhQUFhLElBZDlCO0FBQUE7QUFBQTtBQUFBOztBQUFBLDZDQWVJLG9DQUFvQztBQUN6Qyx1QkFBUyxlQUFLLE9BQUwsQ0FBYSxJQUFiLENBRGdDO0FBRXpDLHVCQUFTLHlCQUZnQztBQUd6QztBQUh5QyxhQUFwQyxDQWZKOztBQUFBO0FBQUEsNkNBc0JFLG9DQUFvQztBQUN6Qyx1QkFBUyxlQUFLLE9BQUwsQ0FBYSxJQUFiLENBRGdDO0FBRXpDLHVCQUFTO0FBQ1AsMENBQTBCO0FBRG5CLGVBRmdDO0FBS3pDO0FBTHlDLGFBQXBDLENBdEJGOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEc7a0JBQWUsNkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1RUEwQ2Ysa0JBQWdELElBQWhEO0FBQUEsUUFBc0QsWUFBdEQseURB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFldkIsUUFBSSxDQUFDLGtCQUFMLEVBQXlCO0FBQ3ZCLFlBQU0sSUFBSSxLQUFKLENBQVUsOERBQVYsQ0FBTjtBQUNEO0FBQ0Y7Ozs7OztBQU1ELE1BQUksTUFBTSxFQUFWO0FBQ0EsTUFBSSxzQkFBc0IsaUJBQUUsR0FBRixDQUFNLGtCQUFOLEVBQTBCLFVBQUMsS0FBRCxFQUFXO0FBQzdELFFBQUkseUJBQXlCLEtBQTdCLEVBQW9DO0FBQ2xDLGFBQU8sTUFBTSxtQkFBTixDQUEwQixHQUExQixDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBTyxJQUFJLEtBQUosRUFBUDtBQUNEO0FBQ0YsR0FOeUIsQ0FBMUI7O0FBUUEsbUJBQUUsTUFBRixDQUFTLG1CQUFULEVBQThCLFVBQUMsR0FBRCxFQUFLLENBQUwsRUFBVztBQUN2QyxRQUFJLFFBQVEsOEJBQXNCLENBQXRCLEVBQXlCLFdBQXJDOztBQUR1QztBQUFBO0FBQUE7O0FBQUE7QUFHdkMsdURBQWlCLE1BQU0saUJBQU4sRUFBakIsaUhBQTRDO0FBQUEsWUFBbkMsSUFBbUM7QUFBRSxZQUFJLElBQUosSUFBWSxDQUFaO0FBQWdCO0FBSHZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSXZDLFdBQU8sR0FBUDtBQUNELEdBTEQsRUFLRyxHQUxIOztBQU9BLFNBQU8sR0FBUDtBQUNEIiwiZmlsZSI6ImNvbmZpZy1wYXJzZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IG1rZGlycCBmcm9tICdta2RpcnAnO1xyXG5pbXBvcnQge3Bmc30gZnJvbSAnLi9wcm9taXNlJztcclxuXHJcbmltcG9ydCBGaWxlQ2hhbmdlZENhY2hlIGZyb20gJy4vZmlsZS1jaGFuZ2UtY2FjaGUnO1xyXG5pbXBvcnQgQ29tcGlsZXJIb3N0IGZyb20gJy4vY29tcGlsZXItaG9zdCc7XHJcbmltcG9ydCByZWdpc3RlclJlcXVpcmVFeHRlbnNpb24gZnJvbSAnLi9yZXF1aXJlLWhvb2snO1xyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6Y29uZmlnLXBhcnNlcicpO1xyXG5cclxuLy8gTkI6IFdlIGludGVudGlvbmFsbHkgZGVsYXktbG9hZCB0aGlzIHNvIHRoYXQgaW4gcHJvZHVjdGlvbiwgeW91IGNhbiBjcmVhdGVcclxuLy8gY2FjaGUtb25seSB2ZXJzaW9ucyBvZiB0aGVzZSBjb21waWxlcnNcclxubGV0IGFsbENvbXBpbGVyQ2xhc3NlcyA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBzdGF0U3luY05vRXhjZXB0aW9uKGZzUGF0aCkge1xyXG4gIGlmICgnc3RhdFN5bmNOb0V4Y2VwdGlvbicgaW4gZnMpIHtcclxuICAgIHJldHVybiBmcy5zdGF0U3luY05vRXhjZXB0aW9uKGZzUGF0aCk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGZzLnN0YXRTeW5jKGZzUGF0aCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgdGhlIGdsb2JhbCBob29rcyAocHJvdG9jb2wgaG9vayBmb3IgZmlsZTosIG5vZGUuanMgaG9vaylcclxuICogaW5kZXBlbmRlbnQgb2YgaW5pdGlhbGl6aW5nIHRoZSBjb21waWxlci4gVGhpcyBtZXRob2QgaXMgdXN1YWxseSBjYWxsZWQgYnlcclxuICogaW5pdCBpbnN0ZWFkIG9mIGRpcmVjdGx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7Q29tcGlsZXJIb3N0fSBjb21waWxlckhvc3QgIFRoZSBjb21waWxlciBob3N0IHRvIHVzZS5cclxuICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplR2xvYmFsSG9va3MoY29tcGlsZXJIb3N0KSB7XHJcbiAgbGV0IGdsb2JhbFZhciA9IChnbG9iYWwgfHwgd2luZG93KTtcclxuICBnbG9iYWxWYXIuZ2xvYmFsQ29tcGlsZXJIb3N0ID0gY29tcGlsZXJIb3N0O1xyXG5cclxuICByZWdpc3RlclJlcXVpcmVFeHRlbnNpb24oY29tcGlsZXJIb3N0KTtcclxuXHJcbiAgaWYgKCd0eXBlJyBpbiBwcm9jZXNzICYmIHByb2Nlc3MudHlwZSA9PT0gJ2Jyb3dzZXInKSB7XHJcbiAgICBjb25zdCB7IGFwcCB9ID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcclxuICAgIGNvbnN0IHsgaW5pdGlhbGl6ZVByb3RvY29sSG9vayB9ID0gcmVxdWlyZSgnLi9wcm90b2NvbC1ob29rJyk7XHJcblxyXG4gICAgbGV0IHByb3RvaWZ5ID0gZnVuY3Rpb24oKSB7IGluaXRpYWxpemVQcm90b2NvbEhvb2soY29tcGlsZXJIb3N0KTsgfTtcclxuICAgIGlmIChhcHAuaXNSZWFkeSgpKSB7XHJcbiAgICAgIHByb3RvaWZ5KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhcHAub24oJ3JlYWR5JywgcHJvdG9pZnkpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGVsZWN0cm9uLWNvbXBpbGUgYW5kIHNldCBpdCB1cCwgZWl0aGVyIGZvciBkZXZlbG9wbWVudCBvclxyXG4gKiBwcm9kdWN0aW9uIHVzZS4gVGhpcyBpcyBhbG1vc3QgYWx3YXlzIHRoZSBvbmx5IG1ldGhvZCB5b3UgbmVlZCB0byB1c2UgaW4gb3JkZXJcclxuICogdG8gdXNlIGVsZWN0cm9uLWNvbXBpbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb25lIHdoaWNoIGhhcyB5b3VyIHBhY2thZ2UuanNvbikuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gbWFpbk1vZHVsZSAgVGhlIG1vZHVsZSB0byByZXF1aXJlIGluLCByZWxhdGl2ZSB0byB0aGUgbW9kdWxlXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGluZyBpbml0LCB0aGF0IHdpbGwgc3RhcnQgeW91ciBhcHAuIFdyaXRlIHRoaXNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyBpZiB5b3Ugd2VyZSB3cml0aW5nIGEgcmVxdWlyZSBjYWxsIGZyb20gaGVyZS5cclxuICpcclxuICogQHBhcmFtICB7Ym9vbH0gcHJvZHVjdGlvbk1vZGUgICBJZiBleHBsaWNpdGx5IFRydWUvRmFsc2UsIHdpbGwgc2V0IHJlYWQtb25seVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgdG8gYmUgZGlzYWJsZWQvZW5hYmxlZC4gSWYgbm90LCB3ZSdsbFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1ZXNzIGJhc2VkIG9uIHRoZSBwcmVzZW5jZSBvZiBhIHByb2R1Y3Rpb25cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSBjYWNoZURpciAgSWYgbm90IHBhc3NlZCBpbiwgcmVhZC1vbmx5IHdpbGwgbG9vayBpblxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYXBwUm9vdC8uY2FjaGVgIGFuZCBkZXYgbW9kZSB3aWxsIGNvbXBpbGUgdG8gYVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wb3JhcnkgZGlyZWN0b3J5LiBJZiBpdCBpcyBwYXNzZWQgaW4sIGJvdGggbW9kZXNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBjYWNoZSB0by9mcm9tIGBhcHBSb290L3tjYWNoZURpcn1gXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5pdChhcHBSb290LCBtYWluTW9kdWxlLCBwcm9kdWN0aW9uTW9kZSA9IG51bGwsIGNhY2hlRGlyID0gbnVsbCkge1xyXG4gIGxldCBjb21waWxlckhvc3QgPSBudWxsO1xyXG4gIGxldCByb290Q2FjaGVEaXIgPSBwYXRoLmpvaW4oYXBwUm9vdCwgY2FjaGVEaXIgfHwgJy5jYWNoZScpO1xyXG5cclxuICBpZiAocHJvZHVjdGlvbk1vZGUgPT09IG51bGwpIHtcclxuICAgIHByb2R1Y3Rpb25Nb2RlID0gISFzdGF0U3luY05vRXhjZXB0aW9uKHJvb3RDYWNoZURpcik7XHJcbiAgfVxyXG5cclxuICBpZiAocHJvZHVjdGlvbk1vZGUpIHtcclxuICAgIGNvbXBpbGVySG9zdCA9IENvbXBpbGVySG9zdC5jcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uU3luYyhyb290Q2FjaGVEaXIsIGFwcFJvb3QpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBpZiBjYWNoZURpciB3YXMgcGFzc2VkIGluLCBwYXNzIGl0IGFsb25nLiBPdGhlcndpc2UsIGRlZmF1bHQgdG8gYSB0ZW1wZGlyLlxyXG4gICAgaWYgKGNhY2hlRGlyKSB7XHJcbiAgICAgIGNvbXBpbGVySG9zdCA9IGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdFN5bmMoYXBwUm9vdCwgcm9vdENhY2hlRGlyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbXBpbGVySG9zdCA9IGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdFN5bmMoYXBwUm9vdCk7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgaW5pdGlhbGl6ZUdsb2JhbEhvb2tzKGNvbXBpbGVySG9zdCk7XHJcbiAgcmVxdWlyZS5tYWluLnJlcXVpcmUobWFpbk1vZHVsZSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHtAbGluayBDb21waWxlckhvc3R9IHdpdGggdGhlIGdpdmVuIGluZm9ybWF0aW9uLiBUaGlzIG1ldGhvZCBpc1xyXG4gKiB1c3VhbGx5IGNhbGxlZCBieSB7QGxpbmsgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290fS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbihpbmZvKSB7XHJcbiAgbGV0IGNvbXBpbGVycyA9IGNyZWF0ZUNvbXBpbGVycygpO1xyXG4gIGxldCByb290Q2FjaGVEaXIgPSBpbmZvLnJvb3RDYWNoZURpciB8fCBjYWxjdWxhdGVEZWZhdWx0Q29tcGlsZUNhY2hlRGlyZWN0b3J5KCk7XHJcblxyXG4gIGQoYENyZWF0aW5nIENvbXBpbGVySG9zdDogJHtKU09OLnN0cmluZ2lmeShpbmZvKX0sIHJvb3RDYWNoZURpciA9ICR7cm9vdENhY2hlRGlyfWApO1xyXG4gIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBuZXcgRmlsZUNoYW5nZWRDYWNoZShpbmZvLmFwcFJvb3QpO1xyXG4gIGxldCByZXQgPSBuZXcgQ29tcGlsZXJIb3N0KHJvb3RDYWNoZURpciwgY29tcGlsZXJzLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBjb21waWxlcnNbJ3RleHQvcGxhaW4nXSk7XHJcblxyXG4gIF8uZWFjaChPYmplY3Qua2V5cyhpbmZvLm9wdGlvbnMgfHwge30pLCAoeCkgPT4ge1xyXG4gICAgbGV0IG9wdHMgPSBpbmZvLm9wdGlvbnNbeF07XHJcbiAgICBpZiAoISh4IGluIGNvbXBpbGVycykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBjb21waWxlciBzZXR0aW5ncyBmb3IgbWlzc2luZyBjb21waWxlcjogJHt4fWApO1xyXG4gICAgfVxyXG5cclxuICAgIGQoYFNldHRpbmcgb3B0aW9ucyBmb3IgJHt4fTogJHtKU09OLnN0cmluZ2lmeShvcHRzKX1gKTtcclxuICAgIGNvbXBpbGVyc1t4XS5jb21waWxlck9wdGlvbnMgPSBvcHRzO1xyXG4gIH0pO1xyXG5cclxuICAvLyBOQjogSXQncyBzdXBlciBpbXBvcnRhbnQgdGhhdCB3ZSBndWFyYW50ZWUgdGhhdCB0aGUgY29uZmlndXJhdGlvbiBpcyBzYXZlZFxyXG4gIC8vIG91dCwgYmVjYXVzZSB3ZSdsbCBuZWVkIHRvIHJlLXJlYWQgaXQgaW4gdGhlIHJlbmRlcmVyIHByb2Nlc3NcclxuICBkKGBDcmVhdGVkIGNvbXBpbGVyIGhvc3Qgd2l0aCBvcHRpb25zOiAke0pTT04uc3RyaW5naWZ5KGluZm8pfWApO1xyXG4gIHJldC5zYXZlQ29uZmlndXJhdGlvblN5bmMoKTtcclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNvbXBpbGVyIGhvc3QgZnJvbSBhIC5iYWJlbHJjIGZpbGUuIFRoaXMgbWV0aG9kIGlzIHVzdWFsbHkgY2FsbGVkXHJcbiAqIGZyb20ge0BsaW5rIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdH0gaW5zdGVhZCBvZiB1c2VkIGRpcmVjdGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGUgIFRoZSBwYXRoIHRvIGEgLmJhYmVscmMgZmlsZVxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAob3B0aW9uYWwpICBUaGUgZGlyZWN0b3J5IHRvIHVzZSBhcyBhIGNhY2hlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHNldC11cCBjb21waWxlciBob3N0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmMoZmlsZSwgcm9vdENhY2hlRGlyPW51bGwpIHtcclxuICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGUsICd1dGY4JykpO1xyXG5cclxuICAvLyBwYWNrYWdlLmpzb25cclxuICBpZiAoJ2JhYmVsJyBpbiBpbmZvKSB7XHJcbiAgICBpbmZvID0gaW5mby5iYWJlbDtcclxuICB9XHJcblxyXG4gIGlmICgnZW52JyBpbiBpbmZvKSB7XHJcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuQkFCRUxfRU5WIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCc7XHJcbiAgICBpbmZvID0gaW5mby5lbnZbb3VyRW52XTtcclxuICB9XHJcblxyXG4gIC8vIEFyZSB3ZSBzdGlsbCBwYWNrYWdlLmpzb24gKGkuZS4gaXMgdGhlcmUgbm8gYmFiZWwgaW5mbyB3aGF0c29ldmVyPylcclxuICBpZiAoJ25hbWUnIGluIGluZm8gJiYgJ3ZlcnNpb24nIGluIGluZm8pIHtcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbih7XHJcbiAgICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcclxuICAgICAgb3B0aW9uczogZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oKSxcclxuICAgICAgcm9vdENhY2hlRGlyXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbih7XHJcbiAgICBhcHBSb290OiBwYXRoLmRpcm5hbWUoZmlsZSksXHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JzogaW5mb1xyXG4gICAgfSxcclxuICAgIHJvb3RDYWNoZURpclxyXG4gIH0pO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjb21waWxlciBob3N0IGZyb20gYSAuY29tcGlsZXJjIGZpbGUuIFRoaXMgbWV0aG9kIGlzIHVzdWFsbHkgY2FsbGVkXHJcbiAqIGZyb20ge0BsaW5rIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdH0gaW5zdGVhZCBvZiB1c2VkIGRpcmVjdGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGUgIFRoZSBwYXRoIHRvIGEgLmNvbXBpbGVyYyBmaWxlXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gcm9vdENhY2hlRGlyIChvcHRpb25hbCkgIFRoZSBkaXJlY3RvcnkgdG8gdXNlIGFzIGEgY2FjaGUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge1Byb21pc2U8Q29tcGlsZXJIb3N0Pn0gIEEgc2V0LXVwIGNvbXBpbGVyIGhvc3RcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlnRmlsZShmaWxlLCByb290Q2FjaGVEaXI9bnVsbCkge1xyXG4gIGxldCBpbmZvID0gSlNPTi5wYXJzZShhd2FpdCBwZnMucmVhZEZpbGUoZmlsZSwgJ3V0ZjgnKSk7XHJcblxyXG4gIGlmICgnZW52JyBpbiBpbmZvKSB7XHJcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuRUxFQ1RST05fQ09NUElMRV9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JztcclxuICAgIGluZm8gPSBpbmZvLmVudltvdXJFbnZdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcclxuICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcclxuICAgIG9wdGlvbnM6IGluZm8sXHJcbiAgICByb290Q2FjaGVEaXJcclxuICB9KTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY29uZmlndXJlZCB7QGxpbmsgQ29tcGlsZXJIb3N0fSBpbnN0YW5jZSBmcm9tIHRoZSBwcm9qZWN0IHJvb3RcclxuICogZGlyZWN0b3J5LiBUaGlzIG1ldGhvZCBmaXJzdCBzZWFyY2hlcyBmb3IgYSAuY29tcGlsZXJjLCB0aGVuIGZhbGxzIGJhY2sgdG8gdGhlXHJcbiAqIGRlZmF1bHQgbG9jYXRpb25zIGZvciBCYWJlbCBjb25maWd1cmF0aW9uIGluZm8uIElmIG5laXRoZXIgYXJlIGZvdW5kLCBkZWZhdWx0c1xyXG4gKiB0byBzdGFuZGFyZCBzZXR0aW5nc1xyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3REaXIgIFRoZSByb290IGFwcGxpY2F0aW9uIGRpcmVjdG9yeSAoaS5lLiB0aGUgZGlyZWN0b3J5XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBoYXMgdGhlIGFwcCdzIHBhY2thZ2UuanNvbilcclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgKG9wdGlvbmFsKSAgVGhlIGRpcmVjdG9yeSB0byB1c2UgYXMgYSBjYWNoZS5cclxuICpcclxuICogQHJldHVybiB7UHJvbWlzZTxDb21waWxlckhvc3Q+fSAgQSBzZXQtdXAgY29tcGlsZXIgaG9zdFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdChyb290RGlyLCByb290Q2FjaGVEaXI9bnVsbCkge1xyXG4gIGxldCBjb21waWxlcmMgPSBwYXRoLmpvaW4ocm9vdERpciwgJy5jb21waWxlcmMnKTtcclxuICBpZiAoc3RhdFN5bmNOb0V4Y2VwdGlvbihjb21waWxlcmMpKSB7XHJcbiAgICBkKGBGb3VuZCBhIC5jb21waWxlcmMgYXQgJHtjb21waWxlcmN9LCB1c2luZyBpdGApO1xyXG4gICAgcmV0dXJuIGF3YWl0IGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlKGNvbXBpbGVyYywgcm9vdENhY2hlRGlyKTtcclxuICB9XHJcblxyXG4gIGxldCBiYWJlbHJjID0gcGF0aC5qb2luKHJvb3REaXIsICcuYmFiZWxyYycpO1xyXG4gIGlmIChzdGF0U3luY05vRXhjZXB0aW9uKGJhYmVscmMpKSB7XHJcbiAgICBkKGBGb3VuZCBhIC5iYWJlbHJjIGF0ICR7YmFiZWxyY30sIHVzaW5nIGl0YCk7XHJcbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmMoYmFiZWxyYywgcm9vdENhY2hlRGlyKTtcclxuICB9XHJcblxyXG4gIGQoYFVzaW5nIHBhY2thZ2UuanNvbiBvciBkZWZhdWx0IHBhcmFtZXRlcnMgYXQgJHtyb290RGlyfWApO1xyXG4gIHJldHVybiBhd2FpdCBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSYyhwYXRoLmpvaW4ocm9vdERpciwgJ3BhY2thZ2UuanNvbicpLCByb290Q2FjaGVEaXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmNTeW5jKGZpbGUsIHJvb3RDYWNoZURpcj1udWxsKSB7XHJcbiAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpKTtcclxuXHJcbiAgLy8gcGFja2FnZS5qc29uXHJcbiAgaWYgKCdiYWJlbCcgaW4gaW5mbykge1xyXG4gICAgaW5mbyA9IGluZm8uYmFiZWw7XHJcbiAgfVxyXG5cclxuICBpZiAoJ2VudicgaW4gaW5mbykge1xyXG4gICAgbGV0IG91ckVudiA9IHByb2Nlc3MuZW52LkJBQkVMX0VOViB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xyXG4gICAgaW5mbyA9IGluZm8uZW52W291ckVudl07XHJcbiAgfVxyXG5cclxuICAvLyBBcmUgd2Ugc3RpbGwgcGFja2FnZS5qc29uIChpLmUuIGlzIHRoZXJlIG5vIGJhYmVsIGluZm8gd2hhdHNvZXZlcj8pXHJcbiAgaWYgKCduYW1lJyBpbiBpbmZvICYmICd2ZXJzaW9uJyBpbiBpbmZvKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xyXG4gICAgICBhcHBSb290OiBwYXRoLmRpcm5hbWUoZmlsZSksXHJcbiAgICAgIG9wdGlvbnM6IGdldERlZmF1bHRDb25maWd1cmF0aW9uKCksXHJcbiAgICAgIHJvb3RDYWNoZURpclxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xyXG4gICAgYXBwUm9vdDogcGF0aC5kaXJuYW1lKGZpbGUpLFxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IGluZm9cclxuICAgIH0sXHJcbiAgICByb290Q2FjaGVEaXJcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlU3luYyhmaWxlLCByb290Q2FjaGVEaXI9bnVsbCkge1xyXG4gIGxldCBpbmZvID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKSk7XHJcblxyXG4gIGlmICgnZW52JyBpbiBpbmZvKSB7XHJcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuRUxFQ1RST05fQ09NUElMRV9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JztcclxuICAgIGluZm8gPSBpbmZvLmVudltvdXJFbnZdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcclxuICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcclxuICAgIG9wdGlvbnM6IGluZm8sXHJcbiAgICByb290Q2FjaGVEaXJcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdFN5bmMocm9vdERpciwgcm9vdENhY2hlRGlyPW51bGwpIHtcclxuICBsZXQgY29tcGlsZXJjID0gcGF0aC5qb2luKHJvb3REaXIsICcuY29tcGlsZXJjJyk7XHJcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oY29tcGlsZXJjKSkge1xyXG4gICAgZChgRm91bmQgYSAuY29tcGlsZXJjIGF0ICR7Y29tcGlsZXJjfSwgdXNpbmcgaXRgKTtcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlnRmlsZVN5bmMoY29tcGlsZXJjLCByb290Q2FjaGVEaXIpO1xyXG4gIH1cclxuXHJcbiAgbGV0IGJhYmVscmMgPSBwYXRoLmpvaW4ocm9vdERpciwgJy5iYWJlbHJjJyk7XHJcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oYmFiZWxyYykpIHtcclxuICAgIGQoYEZvdW5kIGEgLmJhYmVscmMgYXQgJHtiYWJlbHJjfSwgdXNpbmcgaXRgKTtcclxuICAgIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSY1N5bmMoYmFiZWxyYywgcm9vdENhY2hlRGlyKTtcclxuICB9XHJcblxyXG4gIGQoYFVzaW5nIHBhY2thZ2UuanNvbiBvciBkZWZhdWx0IHBhcmFtZXRlcnMgYXQgJHtyb290RGlyfWApO1xyXG4gIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSY1N5bmMocGF0aC5qb2luKHJvb3REaXIsICdwYWNrYWdlLmpzb24nKSwgcm9vdENhY2hlRGlyKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgd2hhdCBlbGVjdHJvbi1jb21waWxlIHdvdWxkIHVzZSBhcyBhIGRlZmF1bHQgcm9vdENhY2hlRGlyLiBVc3VhbGx5IG9ubHlcclxuICogdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXHJcbiAqXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gIEEgcGF0aCB0aGF0IG1heSBvciBtYXkgbm90IGV4aXN0IHdoZXJlIGVsZWN0cm9uLWNvbXBpbGUgd291bGRcclxuICogICAgICAgICAgICAgICAgICAgc2V0IHVwIGEgZGV2ZWxvcG1lbnQgbW9kZSBjYWNoZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEZWZhdWx0Q29tcGlsZUNhY2hlRGlyZWN0b3J5KCkge1xyXG4gIGxldCB0bXBEaXIgPSBwcm9jZXNzLmVudi5URU1QIHx8IHByb2Nlc3MuZW52LlRNUERJUiB8fCAnL3RtcCc7XHJcbiAgbGV0IGhhc2ggPSByZXF1aXJlKCdjcnlwdG8nKS5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUocHJvY2Vzcy5leGVjUGF0aCkuZGlnZXN0KCdoZXgnKTtcclxuXHJcbiAgbGV0IGNhY2hlRGlyID0gcGF0aC5qb2luKHRtcERpciwgYGNvbXBpbGVDYWNoZV8ke2hhc2h9YCk7XHJcbiAgbWtkaXJwLnN5bmMoY2FjaGVEaXIpO1xyXG5cclxuICBkKGBVc2luZyBkZWZhdWx0IGNhY2hlIGRpcmVjdG9yeTogJHtjYWNoZURpcn1gKTtcclxuICByZXR1cm4gY2FjaGVEaXI7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGVmYXVsdCAuY29uZmlncmMgaWYgbm8gY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gIEEgbGlzdCBvZiBkZWZhdWx0IGNvbmZpZyBzZXR0aW5ncyBmb3IgZWxlY3Ryb24tY29tcGlsZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0Jzoge1xyXG4gICAgICBcInByZXNldHNcIjogW1wic3RhZ2UtMFwiLCBcImVzMjAxNVwiLCBcInJlYWN0XCJdLFxyXG4gICAgICBcInNvdXJjZU1hcHNcIjogXCJpbmxpbmVcIlxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgeW91IHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9mIGFsbCBjb21waWxlcnMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5XHJcbiAqIGVsZWN0cm9uLWNvbXBpbGUgYW5kIHVzZSB0aGVtIGRpcmVjdGx5LiBDdXJyZW50bHkgc3VwcG9ydHMgQmFiZWwsIENvZmZlZVNjcmlwdCxcclxuICogVHlwZVNjcmlwdCwgTGVzcywgYW5kIEphZGUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gIEFuIE9iamVjdCB3aG9zZSBLZXlzIGFyZSBNSU1FIHR5cGVzLCBhbmQgd2hvc2UgdmFsdWVzXHJcbiAqIGFyZSBpbnN0YW5jZXMgb2YgQHtsaW5rIENvbXBpbGVyQmFzZX0uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJzKCkge1xyXG4gIGlmICghYWxsQ29tcGlsZXJDbGFzc2VzKSB7XHJcbiAgICAvLyBGaXJzdCB3ZSB3YW50IHRvIHNlZSBpZiBlbGVjdHJvbi1jb21waWxlcnMgaXRzZWxmIGhhcyBiZWVuIGluc3RhbGxlZCB3aXRoXHJcbiAgICAvLyBkZXZEZXBlbmRlbmNpZXMuIElmIHRoYXQncyBub3QgdGhlIGNhc2UsIGNoZWNrIHRvIHNlZSBpZlxyXG4gICAgLy8gZWxlY3Ryb24tY29tcGlsZXJzIGlzIGluc3RhbGxlZCBhcyBhIHBlZXIgZGVwZW5kZW5jeSAocHJvYmFibHkgYXMgYVxyXG4gICAgLy8gZGV2RGVwZW5kZW5jeSBvZiB0aGUgcm9vdCBwcm9qZWN0KS5cclxuICAgIGNvbnN0IGxvY2F0aW9ucyA9IFsnZWxlY3Ryb24tY29tcGlsZXJzJywgJy4uLy4uL2VsZWN0cm9uLWNvbXBpbGVycyddO1xyXG5cclxuICAgIGZvciAobGV0IGxvY2F0aW9uIG9mIGxvY2F0aW9ucykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGFsbENvbXBpbGVyQ2xhc3NlcyA9IHJlcXVpcmUobG9jYXRpb24pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gWW9sb1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhbGxDb21waWxlckNsYXNzZXMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlY3Ryb24gY29tcGlsZXJzIG5vdCBmb3VuZCBidXQgd2VyZSByZXF1ZXN0ZWQgdG8gYmUgbG9hZGVkXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTkI6IE5vdGUgdGhhdCB0aGlzIGNvZGUgaXMgY2FyZWZ1bGx5IHNldCB1cCBzbyB0aGF0IElubGluZUh0bWxDb21waWxlclxyXG4gIC8vIChpLmUuIGNsYXNzZXMgd2l0aCBgY3JlYXRlRnJvbUNvbXBpbGVyc2ApIGluaXRpYWxseSBnZXQgYW4gZW1wdHkgb2JqZWN0LFxyXG4gIC8vIGJ1dCB3aWxsIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGZpbmFsIHJlc3VsdCBvZiB3aGF0IHdlIHJldHVybiwgd2hpY2hcclxuICAvLyByZXNvbHZlcyB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeSB3ZSdkIG90aGVyd2lzZSBoYXZlIGhlcmUuXHJcbiAgbGV0IHJldCA9IHt9O1xyXG4gIGxldCBpbnN0YW50aWF0ZWRDbGFzc2VzID0gXy5tYXAoYWxsQ29tcGlsZXJDbGFzc2VzLCAoS2xhc3MpID0+IHtcclxuICAgIGlmICgnY3JlYXRlRnJvbUNvbXBpbGVycycgaW4gS2xhc3MpIHtcclxuICAgICAgcmV0dXJuIEtsYXNzLmNyZWF0ZUZyb21Db21waWxlcnMocmV0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBuZXcgS2xhc3MoKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgXy5yZWR1Y2UoaW5zdGFudGlhdGVkQ2xhc3NlcywgKGFjYyx4KSA9PiB7XHJcbiAgICBsZXQgS2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkuY29uc3RydWN0b3I7XHJcblxyXG4gICAgZm9yIChsZXQgdHlwZSBvZiBLbGFzcy5nZXRJbnB1dE1pbWVUeXBlcygpKSB7IGFjY1t0eXBlXSA9IHg7IH1cclxuICAgIHJldHVybiBhY2M7XHJcbiAgfSwgcmV0KTtcclxuXHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG4iXX0=