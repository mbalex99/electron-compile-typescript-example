'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _promise = require('./promise');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sanitizePaths = require('./sanitize-paths');

var _sanitizePaths2 = _interopRequireDefault(_sanitizePaths);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var d = require('debug')('electron-compile:file-change-cache');

/**
 * This class caches information about files and determines whether they have
 * changed contents or not. Most importantly, this class caches the hash of seen
 * files so that at development time, we don't have to recalculate them constantly.
 *
 * This class is also the core of how electron-compile runs quickly in production
 * mode - after precompilation, the cache is serialized along with the rest of the
 * data in {@link CompilerHost}, so that when we load the app in production mode,
 * we don't end up calculating hashes of file content at all, only using the contents
 * of this cache.
 */

var FileChangedCache = function () {
  function FileChangedCache(appRoot) {
    var failOnCacheMiss = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
    (0, _classCallCheck3.default)(this, FileChangedCache);

    this.appRoot = (0, _sanitizePaths2.default)(appRoot);

    this.failOnCacheMiss = failOnCacheMiss;
    this.changeCache = {};
  }

  /**
   * Allows you to create a FileChangedCache from serialized data saved from
   * {@link getSavedData}.
   *
   * @param  {Object} data  Saved data from getSavedData.
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.
   *
   * @return {FileChangedCache}
   */


  (0, _createClass3.default)(FileChangedCache, [{
    key: 'getHashForPath',


    /**
     * Returns information about a given file, including its hash. This method is
     * the main method for this cache.
     *
     * @param  {string} absoluteFilePath  The path to a file to retrieve info on.
     *
     * @return {Promise<Object>}
     *
     * @property {string} hash  The SHA1 hash of the file
     * @property {boolean} isMinified  True if the file is minified
     * @property {boolean} isInNodeModules  True if the file is in a library directory
     * @property {boolean} hasSourceMap  True if the file has a source map
     * @property {boolean} isFileBinary  True if the file is not a text file
     * @property {Buffer} binaryData (optional)  The buffer that was read if the file
     *                                           was binary and there was a cache miss.
     * @property {string} code (optional)  The string that was read if the file
     *                                     was text and there was a cache miss
     */
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(absoluteFilePath) {
        var cacheKey, cacheEntry, stat, ctime, size, _ref, digest, sourceCode, binaryData, info;

        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);

                if (this.appRoot) {
                  cacheKey = cacheKey.replace(this.appRoot, '');
                }

                // NB: We do this because x-require will include an absolute path from the
                // original built app and we need to still grok it
                if (this.originalAppRoot) {
                  cacheKey = cacheKey.replace(this.originalAppRoot, '');
                }

                cacheEntry = this.changeCache[cacheKey];

                if (!this.failOnCacheMiss) {
                  _context.next = 10;
                  break;
                }

                if (cacheEntry) {
                  _context.next = 9;
                  break;
                }

                d('Tried to read file cache entry for ' + absoluteFilePath);
                d('cacheKey: ' + cacheKey + ', appRoot: ' + this.appRoot + ', originalAppRoot: ' + this.originalAppRoot);
                throw new Error('Asked for ' + absoluteFilePath + ' but it was not precompiled!');

              case 9:
                return _context.abrupt('return', cacheEntry.info);

              case 10:
                _context.next = 12;
                return _promise.pfs.stat(absoluteFilePath);

              case 12:
                stat = _context.sent;
                ctime = stat.ctime.getTime();
                size = stat.size;

                if (!(!stat || !stat.isFile())) {
                  _context.next = 17;
                  break;
                }

                throw new Error('Can\'t stat ' + absoluteFilePath);

              case 17:
                if (!cacheEntry) {
                  _context.next = 22;
                  break;
                }

                if (!(cacheEntry.ctime >= ctime && cacheEntry.size === size)) {
                  _context.next = 20;
                  break;
                }

                return _context.abrupt('return', cacheEntry.info);

              case 20:

                d('Invalidating cache entry: ' + cacheEntry.ctime + ' === ' + ctime + ' && ' + cacheEntry.size + ' === ' + size);
                delete this.changeCache.cacheEntry;

              case 22:
                _context.next = 24;
                return this.calculateHashForFile(absoluteFilePath);

              case 24:
                _ref = _context.sent;
                digest = _ref.digest;
                sourceCode = _ref.sourceCode;
                binaryData = _ref.binaryData;
                info = {
                  hash: digest,
                  isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),
                  isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),
                  hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),
                  isFileBinary: !!binaryData
                };


                this.changeCache[cacheKey] = { ctime: ctime, size: size, info: info };
                d('Cache entry for ' + cacheKey + ': ' + (0, _stringify2.default)(this.changeCache[cacheKey]));

                if (!binaryData) {
                  _context.next = 35;
                  break;
                }

                return _context.abrupt('return', _lodash2.default.extend({ binaryData: binaryData }, info));

              case 35:
                return _context.abrupt('return', _lodash2.default.extend({ sourceCode: sourceCode }, info));

              case 36:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getHashForPath(_x2) {
        return ref.apply(this, arguments);
      }

      return getHashForPath;
    }()

    /**
     * Returns data that can passed to {@link loadFromData} to rehydrate this cache.
     *
     * @return {Object}
     */

  }, {
    key: 'getSavedData',
    value: function getSavedData() {
      return { changeCache: this.changeCache, appRoot: this.appRoot };
    }

    /**
     * Serializes this object's data to a file.
     *
     * @param {string} filePath  The path to save data to.
     *
     * @return {Promise} Completion.
     */

  }, {
    key: 'save',
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(filePath) {
        var toSave, buf;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                toSave = this.getSavedData();
                _context2.next = 3;
                return _promise.pzlib.gzip(new Buffer((0, _stringify2.default)(toSave)));

              case 3:
                buf = _context2.sent;
                _context2.next = 6;
                return _promise.pfs.writeFile(filePath, buf);

              case 6:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function save(_x3) {
        return ref.apply(this, arguments);
      }

      return save;
    }()
  }, {
    key: 'calculateHashForFile',
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(absoluteFilePath) {
        var buf, encoding, _digest, sourceCode, digest;

        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _promise.pfs.readFile(absoluteFilePath);

              case 2:
                buf = _context3.sent;
                encoding = FileChangedCache.detectFileEncoding(buf);

                if (encoding) {
                  _context3.next = 7;
                  break;
                }

                _digest = _crypto2.default.createHash('sha1').update(buf).digest('hex');
                return _context3.abrupt('return', { sourceCode: null, digest: _digest, binaryData: buf });

              case 7:
                _context3.next = 9;
                return _promise.pfs.readFile(absoluteFilePath, encoding);

              case 9:
                sourceCode = _context3.sent;
                digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');
                return _context3.abrupt('return', { sourceCode: sourceCode, digest: digest, binaryData: null });

              case 12:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function calculateHashForFile(_x4) {
        return ref.apply(this, arguments);
      }

      return calculateHashForFile;
    }()
  }, {
    key: 'getHashForPathSync',
    value: function getHashForPathSync(absoluteFilePath) {
      var cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);
      if (this.appRoot) {
        cacheKey = cacheKey.replace(this.appRoot, '');
      }

      // NB: We do this because x-require will include an absolute path from the
      // original built app and we need to still grok it
      if (this.originalAppRoot) {
        cacheKey = cacheKey.replace(this.originalAppRoot, '');
      }

      if (this.realAppRoot) {
        cacheKey = cacheKey.replace(this.realAppRoot, '');
      }

      var cacheEntry = this.changeCache[cacheKey];

      if (this.failOnCacheMiss) {
        if (!cacheEntry) {
          d('Tried to read file cache entry for ' + absoluteFilePath);
          d('cacheKey: ' + cacheKey + ', appRoot: ' + this.appRoot + ', originalAppRoot: ' + this.originalAppRoot);
          throw new Error('Asked for ' + absoluteFilePath + ' but it was not precompiled!');
        }

        return cacheEntry.info;
      }

      var stat = _fs2.default.statSync(absoluteFilePath);
      var ctime = stat.ctime.getTime();
      var size = stat.size;
      if (!stat || !stat.isFile()) throw new Error('Can\'t stat ' + absoluteFilePath);

      if (cacheEntry) {
        if (cacheEntry.ctime >= ctime && cacheEntry.size === size) {
          return cacheEntry.info;
        }

        d('Invalidating cache entry: ' + cacheEntry.ctime + ' === ' + ctime + ' && ' + cacheEntry.size + ' === ' + size);
        delete this.changeCache.cacheEntry;
      }

      var _calculateHashForFile = this.calculateHashForFileSync(absoluteFilePath);

      var digest = _calculateHashForFile.digest;
      var sourceCode = _calculateHashForFile.sourceCode;
      var binaryData = _calculateHashForFile.binaryData;


      var info = {
        hash: digest,
        isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),
        isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),
        hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),
        isFileBinary: !!binaryData
      };

      this.changeCache[cacheKey] = { ctime: ctime, size: size, info: info };
      d('Cache entry for ' + cacheKey + ': ' + (0, _stringify2.default)(this.changeCache[cacheKey]));

      if (binaryData) {
        return _lodash2.default.extend({ binaryData: binaryData }, info);
      } else {
        return _lodash2.default.extend({ sourceCode: sourceCode }, info);
      }
    }
  }, {
    key: 'saveSync',
    value: function saveSync(filePath) {
      var toSave = this.getSavedData();

      var buf = _zlib2.default.gzipSync(new Buffer((0, _stringify2.default)(toSave)));
      _fs2.default.writeFileSync(filePath, buf);
    }
  }, {
    key: 'calculateHashForFileSync',
    value: function calculateHashForFileSync(absoluteFilePath) {
      var buf = _fs2.default.readFileSync(absoluteFilePath);
      var encoding = FileChangedCache.detectFileEncoding(buf);

      if (!encoding) {
        var _digest2 = _crypto2.default.createHash('sha1').update(buf).digest('hex');
        return { sourceCode: null, digest: _digest2, binaryData: buf };
      }

      var sourceCode = _fs2.default.readFileSync(absoluteFilePath, encoding);
      var digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');

      return { sourceCode: sourceCode, digest: digest, binaryData: null };
    }

    /**
     * Determines via some statistics whether a file is likely to be minified.
     *
     * @private
     */

  }], [{
    key: 'loadFromData',
    value: function loadFromData(data, appRoot) {
      var failOnCacheMiss = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

      var ret = new FileChangedCache(appRoot, failOnCacheMiss);
      ret.changeCache = data.changeCache;
      ret.originalAppRoot = data.appRoot;

      return ret;
    }

    /**
     * Allows you to create a FileChangedCache from serialized data saved from
     * {@link save}.
     *
     * @param  {string} file  Saved data from save.
     *
     * @param  {string} appRoot  The top-level directory for your application (i.e.
     *                           the one which has your package.json).
     *
     * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.
     *
     * @return {Promise<FileChangedCache>}
     */

  }, {
    key: 'loadFromFile',
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(file, appRoot) {
        var failOnCacheMiss = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
        var buf;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                d('Loading canned FileChangedCache from ' + file);

                _context4.next = 3;
                return _promise.pfs.readFile(file);

              case 3:
                buf = _context4.sent;
                _context4.t0 = FileChangedCache;
                _context4.t1 = JSON;
                _context4.next = 8;
                return _promise.pzlib.gunzip(buf);

              case 8:
                _context4.t2 = _context4.sent;
                _context4.t3 = _context4.t1.parse.call(_context4.t1, _context4.t2);
                _context4.t4 = appRoot;
                _context4.t5 = failOnCacheMiss;
                return _context4.abrupt('return', _context4.t0.loadFromData.call(_context4.t0, _context4.t3, _context4.t4, _context4.t5));

              case 13:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function loadFromFile(_x7, _x8) {
        return ref.apply(this, arguments);
      }

      return loadFromFile;
    }()
  }, {
    key: 'contentsAreMinified',
    value: function contentsAreMinified(source) {
      var length = source.length;
      if (length > 1024) length = 1024;

      var newlineCount = 0;

      // Roll through the characters and determine the average line length
      for (var i = 0; i < source.length; i++) {
        if (source[i] === '\n') newlineCount++;
      }

      // No Newlines? Any file other than a super small one is minified
      if (newlineCount === 0) {
        return length > 80;
      }

      var avgLineLength = length / newlineCount;
      return avgLineLength > 80;
    }

    /**
     * Determines whether a path is in node_modules or the Electron init code
     *
     * @private
     */

  }, {
    key: 'isInNodeModules',
    value: function isInNodeModules(filePath) {
      return !!(filePath.match(/(node_modules|bower_components)[\\\/]/i) || filePath.match(/(atom|electron)\.asar/));
    }

    /**
     * Returns whether a file has an inline source map
     *
     * @private
     */

  }, {
    key: 'hasSourceMap',
    value: function hasSourceMap(sourceCode) {
      var trimmed = sourceCode.trim();
      return trimmed.lastIndexOf('//# sourceMap') > trimmed.lastIndexOf('\n');
    }

    /**
     * Determines the encoding of a file from the two most common encodings by trying
     * to decode it then looking for encoding errors
     *
     * @private
     */

  }, {
    key: 'detectFileEncoding',
    value: function detectFileEncoding(buffer) {
      if (buffer.length < 1) return false;
      var buf = buffer.length < 4096 ? buffer : buffer.slice(0, 4096);

      var encodings = ['utf8', 'utf16le'];

      var encoding = _lodash2.default.find(encodings, function (x) {
        return !FileChangedCache.containsControlCharacters(buf.toString(x));
      });

      return encoding;
    }

    /**
     * Determines whether a string is likely to be poorly encoded by looking for
     * control characters above a certain threshold
     *
     * @private
     */

  }, {
    key: 'containsControlCharacters',
    value: function containsControlCharacters(str) {
      var controlCount = 0;
      var spaceCount = 0;
      var threshold = 2;
      if (str.length > 64) threshold = 4;
      if (str.length > 512) threshold = 8;

      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c === 65536 || c < 8) controlCount++;
        if (c > 14 && c < 32) controlCount++;
        if (c === 32) spaceCount++;

        if (controlCount > threshold) return true;
      }

      if (spaceCount < threshold) return true;

      if (controlCount === 0) return false;
      return controlCount / str.length < 0.02;
    }
  }]);
  return FileChangedCache;
}();

exports.default = FileChangedCache;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWxlLWNoYW5nZS1jYWNoZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQU0sSUFBSSxRQUFRLE9BQVIsRUFBaUIsb0NBQWpCLENBQVY7Ozs7Ozs7Ozs7Ozs7O0lBYXFCLGdCO0FBQ25CLDRCQUFZLE9BQVosRUFBNEM7QUFBQSxRQUF2QixlQUF1Qix5REFBUCxLQUFPO0FBQUE7O0FBQzFDLFNBQUssT0FBTCxHQUFlLDZCQUFpQixPQUFqQixDQUFmOztBQUVBLFNBQUssZUFBTCxHQUF1QixlQUF2QjtBQUNBLFNBQUssV0FBTCxHQUFtQixFQUFuQjtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRGQStEb0IsZ0I7WUFDZixRLEVBV0EsVSxFQVlBLEksRUFDQSxLLEVBQ0EsSSxRQVlDLE0sRUFBUSxVLEVBQVksVSxFQUVyQixJOzs7Ozs7QUF2Q0Esd0IsR0FBVyw2QkFBaUIsZ0JBQWpCLEM7O0FBQ2Ysb0JBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2hCLDZCQUFXLFNBQVMsT0FBVCxDQUFpQixLQUFLLE9BQXRCLEVBQStCLEVBQS9CLENBQVg7QUFDRDs7OztBQUlELG9CQUFJLEtBQUssZUFBVCxFQUEwQjtBQUN4Qiw2QkFBVyxTQUFTLE9BQVQsQ0FBaUIsS0FBSyxlQUF0QixFQUF1QyxFQUF2QyxDQUFYO0FBQ0Q7O0FBRUcsMEIsR0FBYSxLQUFLLFdBQUwsQ0FBaUIsUUFBakIsQzs7cUJBRWIsS0FBSyxlOzs7OztvQkFDRixVOzs7OztBQUNILDBEQUF3QyxnQkFBeEM7QUFDQSxpQ0FBZSxRQUFmLG1CQUFxQyxLQUFLLE9BQTFDLDJCQUF1RSxLQUFLLGVBQTVFO3NCQUNNLElBQUksS0FBSixnQkFBdUIsZ0JBQXZCLGtDOzs7aURBR0QsV0FBVyxJOzs7O3VCQUdILGFB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LE1BQUosR0FBYSxFQUFqQixFQUFxQixZQUFZLENBQVo7QUFDckIsVUFBSSxJQUFJLE1BQUosR0FBYSxHQUFqQixFQUFzQixZQUFZLENBQVo7O0FBRXRCLFdBQUssSUFBSSxJQUFFLENBQVgsRUFBYyxJQUFJLElBQUksTUFBdEIsRUFBOEIsR0FBOUIsRUFBbUM7QUFDakMsWUFBSSxJQUFJLElBQUksVUFBSixDQUFlLENBQWYsQ0FBUjtBQUNBLFlBQUksTUFBTSxLQUFOLElBQWUsSUFBSSxDQUF2QixFQUEwQjtBQUMxQixZQUFJLElBQUksRUFBSixJQUFVLElBQUksRUFBbEIsRUFBc0I7QUFDdEIsWUFBSSxNQUFNLEVBQVYsRUFBYzs7QUFFZCxZQUFJLGVBQWUsU0FBbkIsRUFBOEIsT0FBTyxJQUFQO0FBQy9COztBQUVELFVBQUksYUFBYSxTQUFqQixFQUE0QixPQUFPLElBQVA7O0FBRTVCLFVBQUksaUJBQWlCLENBQXJCLEVBQXdCLE9BQU8sS0FBUDtBQUN4QixhQUFRLGVBQWUsSUFBSSxNQUFwQixHQUE4QixJQUFyQztBQUNEOzs7OztrQkF0VmtCLGdCIiwiZmlsZSI6ImZpbGUtY2hhbmdlLWNhY2hlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XHJcbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcclxuaW1wb3J0IHtwZnMsIHB6bGlifSBmcm9tICcuL3Byb21pc2UnO1xyXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgc2FuaXRpemVGaWxlUGF0aCBmcm9tICcuL3Nhbml0aXplLXBhdGhzJztcclxuXHJcbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOmZpbGUtY2hhbmdlLWNhY2hlJyk7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBjYWNoZXMgaW5mb3JtYXRpb24gYWJvdXQgZmlsZXMgYW5kIGRldGVybWluZXMgd2hldGhlciB0aGV5IGhhdmVcclxuICogY2hhbmdlZCBjb250ZW50cyBvciBub3QuIE1vc3QgaW1wb3J0YW50bHksIHRoaXMgY2xhc3MgY2FjaGVzIHRoZSBoYXNoIG9mIHNlZW5cclxuICogZmlsZXMgc28gdGhhdCBhdCBkZXZlbG9wbWVudCB0aW1lLCB3ZSBkb24ndCBoYXZlIHRvIHJlY2FsY3VsYXRlIHRoZW0gY29uc3RhbnRseS5cclxuICpcclxuICogVGhpcyBjbGFzcyBpcyBhbHNvIHRoZSBjb3JlIG9mIGhvdyBlbGVjdHJvbi1jb21waWxlIHJ1bnMgcXVpY2tseSBpbiBwcm9kdWN0aW9uXHJcbiAqIG1vZGUgLSBhZnRlciBwcmVjb21waWxhdGlvbiwgdGhlIGNhY2hlIGlzIHNlcmlhbGl6ZWQgYWxvbmcgd2l0aCB0aGUgcmVzdCBvZiB0aGVcclxuICogZGF0YSBpbiB7QGxpbmsgQ29tcGlsZXJIb3N0fSwgc28gdGhhdCB3aGVuIHdlIGxvYWQgdGhlIGFwcCBpbiBwcm9kdWN0aW9uIG1vZGUsXHJcbiAqIHdlIGRvbid0IGVuZCB1cCBjYWxjdWxhdGluZyBoYXNoZXMgb2YgZmlsZSBjb250ZW50IGF0IGFsbCwgb25seSB1c2luZyB0aGUgY29udGVudHNcclxuICogb2YgdGhpcyBjYWNoZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVDaGFuZ2VkQ2FjaGUge1xyXG4gIGNvbnN0cnVjdG9yKGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcz1mYWxzZSkge1xyXG4gICAgdGhpcy5hcHBSb290ID0gc2FuaXRpemVGaWxlUGF0aChhcHBSb290KTtcclxuXHJcbiAgICB0aGlzLmZhaWxPbkNhY2hlTWlzcyA9IGZhaWxPbkNhY2hlTWlzcztcclxuICAgIHRoaXMuY2hhbmdlQ2FjaGUgPSB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsbG93cyB5b3UgdG8gY3JlYXRlIGEgRmlsZUNoYW5nZWRDYWNoZSBmcm9tIHNlcmlhbGl6ZWQgZGF0YSBzYXZlZCBmcm9tXHJcbiAgICoge0BsaW5rIGdldFNhdmVkRGF0YX0uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgIFNhdmVkIGRhdGEgZnJvbSBnZXRTYXZlZERhdGEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFwcFJvb3QgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IGZvciB5b3VyIGFwcGxpY2F0aW9uIChpLmUuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb25lIHdoaWNoIGhhcyB5b3VyIHBhY2thZ2UuanNvbikuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBmYWlsT25DYWNoZU1pc3MgKG9wdGlvbmFsKSAgSWYgVHJ1ZSwgY2FjaGUgbWlzc2VzIHdpbGwgdGhyb3cuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtGaWxlQ2hhbmdlZENhY2hlfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBsb2FkRnJvbURhdGEoZGF0YSwgYXBwUm9vdCwgZmFpbE9uQ2FjaGVNaXNzPXRydWUpIHtcclxuICAgIGxldCByZXQgPSBuZXcgRmlsZUNoYW5nZWRDYWNoZShhcHBSb290LCBmYWlsT25DYWNoZU1pc3MpO1xyXG4gICAgcmV0LmNoYW5nZUNhY2hlID0gZGF0YS5jaGFuZ2VDYWNoZTtcclxuICAgIHJldC5vcmlnaW5hbEFwcFJvb3QgPSBkYXRhLmFwcFJvb3Q7XHJcblxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBBbGxvd3MgeW91IHRvIGNyZWF0ZSBhIEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSBzZXJpYWxpemVkIGRhdGEgc2F2ZWQgZnJvbVxyXG4gICAqIHtAbGluayBzYXZlfS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZSAgU2F2ZWQgZGF0YSBmcm9tIHNhdmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFwcFJvb3QgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IGZvciB5b3VyIGFwcGxpY2F0aW9uIChpLmUuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb25lIHdoaWNoIGhhcyB5b3VyIHBhY2thZ2UuanNvbikuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBmYWlsT25DYWNoZU1pc3MgKG9wdGlvbmFsKSAgSWYgVHJ1ZSwgY2FjaGUgbWlzc2VzIHdpbGwgdGhyb3cuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEZpbGVDaGFuZ2VkQ2FjaGU+fVxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBsb2FkRnJvbUZpbGUoZmlsZSwgYXBwUm9vdCwgZmFpbE9uQ2FjaGVNaXNzPXRydWUpIHtcclxuICAgIGQoYExvYWRpbmcgY2FubmVkIEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSAke2ZpbGV9YCk7XHJcblxyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlKTtcclxuICAgIHJldHVybiBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShKU09OLnBhcnNlKGF3YWl0IHB6bGliLmd1bnppcChidWYpKSwgYXBwUm9vdCwgZmFpbE9uQ2FjaGVNaXNzKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IGEgZ2l2ZW4gZmlsZSwgaW5jbHVkaW5nIGl0cyBoYXNoLiBUaGlzIG1ldGhvZCBpc1xyXG4gICAqIHRoZSBtYWluIG1ldGhvZCBmb3IgdGhpcyBjYWNoZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYWJzb2x1dGVGaWxlUGF0aCAgVGhlIHBhdGggdG8gYSBmaWxlIHRvIHJldHJpZXZlIGluZm8gb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59XHJcbiAgICpcclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gaGFzaCAgVGhlIFNIQTEgaGFzaCBvZiB0aGUgZmlsZVxyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNNaW5pZmllZCAgVHJ1ZSBpZiB0aGUgZmlsZSBpcyBtaW5pZmllZFxyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNJbk5vZGVNb2R1bGVzICBUcnVlIGlmIHRoZSBmaWxlIGlzIGluIGEgbGlicmFyeSBkaXJlY3RvcnlcclxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGhhc1NvdXJjZU1hcCAgVHJ1ZSBpZiB0aGUgZmlsZSBoYXMgYSBzb3VyY2UgbWFwXHJcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBpc0ZpbGVCaW5hcnkgIFRydWUgaWYgdGhlIGZpbGUgaXMgbm90IGEgdGV4dCBmaWxlXHJcbiAgICogQHByb3BlcnR5IHtCdWZmZXJ9IGJpbmFyeURhdGEgKG9wdGlvbmFsKSAgVGhlIGJ1ZmZlciB0aGF0IHdhcyByZWFkIGlmIHRoZSBmaWxlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzIGJpbmFyeSBhbmQgdGhlcmUgd2FzIGEgY2FjaGUgbWlzcy5cclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gY29kZSAob3B0aW9uYWwpICBUaGUgc3RyaW5nIHRoYXQgd2FzIHJlYWQgaWYgdGhlIGZpbGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXMgdGV4dCBhbmQgdGhlcmUgd2FzIGEgY2FjaGUgbWlzc1xyXG4gICAqL1xyXG4gIGFzeW5jIGdldEhhc2hGb3JQYXRoKGFic29sdXRlRmlsZVBhdGgpIHtcclxuICAgIGxldCBjYWNoZUtleSA9IHNhbml0aXplRmlsZVBhdGgoYWJzb2x1dGVGaWxlUGF0aCk7XHJcbiAgICBpZiAodGhpcy5hcHBSb290KSB7XHJcbiAgICAgIGNhY2hlS2V5ID0gY2FjaGVLZXkucmVwbGFjZSh0aGlzLmFwcFJvb3QsICcnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOQjogV2UgZG8gdGhpcyBiZWNhdXNlIHgtcmVxdWlyZSB3aWxsIGluY2x1ZGUgYW4gYWJzb2x1dGUgcGF0aCBmcm9tIHRoZVxyXG4gICAgLy8gb3JpZ2luYWwgYnVpbHQgYXBwIGFuZCB3ZSBuZWVkIHRvIHN0aWxsIGdyb2sgaXRcclxuICAgIGlmICh0aGlzLm9yaWdpbmFsQXBwUm9vdCkge1xyXG4gICAgICBjYWNoZUtleSA9IGNhY2hlS2V5LnJlcGxhY2UodGhpcy5vcmlnaW5hbEFwcFJvb3QsICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGVFbnRyeSA9IHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldO1xyXG5cclxuICAgIGlmICh0aGlzLmZhaWxPbkNhY2hlTWlzcykge1xyXG4gICAgICBpZiAoIWNhY2hlRW50cnkpIHtcclxuICAgICAgICBkKGBUcmllZCB0byByZWFkIGZpbGUgY2FjaGUgZW50cnkgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH1gKTtcclxuICAgICAgICBkKGBjYWNoZUtleTogJHtjYWNoZUtleX0sIGFwcFJvb3Q6ICR7dGhpcy5hcHBSb290fSwgb3JpZ2luYWxBcHBSb290OiAke3RoaXMub3JpZ2luYWxBcHBSb290fWApO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH0gYnV0IGl0IHdhcyBub3QgcHJlY29tcGlsZWQhYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZm87XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHN0YXQgPSBhd2FpdCBwZnMuc3RhdChhYnNvbHV0ZUZpbGVQYXRoKTtcclxuICAgIGxldCBjdGltZSA9IHN0YXQuY3RpbWUuZ2V0VGltZSgpO1xyXG4gICAgbGV0IHNpemUgPSBzdGF0LnNpemU7XHJcbiAgICBpZiAoIXN0YXQgfHwgIXN0YXQuaXNGaWxlKCkpIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3RhdCAke2Fic29sdXRlRmlsZVBhdGh9YCk7XHJcblxyXG4gICAgaWYgKGNhY2hlRW50cnkpIHtcclxuICAgICAgaWYgKGNhY2hlRW50cnkuY3RpbWUgPj0gY3RpbWUgJiYgY2FjaGVFbnRyeS5zaXplID09PSBzaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkuaW5mbztcclxuICAgICAgfVxyXG5cclxuICAgICAgZChgSW52YWxpZGF0aW5nIGNhY2hlIGVudHJ5OiAke2NhY2hlRW50cnkuY3RpbWV9ID09PSAke2N0aW1lfSAmJiAke2NhY2hlRW50cnkuc2l6ZX0gPT09ICR7c2l6ZX1gKTtcclxuICAgICAgZGVsZXRlIHRoaXMuY2hhbmdlQ2FjaGUuY2FjaGVFbnRyeTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQge2RpZ2VzdCwgc291cmNlQ29kZSwgYmluYXJ5RGF0YX0gPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZUhhc2hGb3JGaWxlKGFic29sdXRlRmlsZVBhdGgpO1xyXG5cclxuICAgIGxldCBpbmZvID0ge1xyXG4gICAgICBoYXNoOiBkaWdlc3QsXHJcbiAgICAgIGlzTWluaWZpZWQ6IEZpbGVDaGFuZ2VkQ2FjaGUuY29udGVudHNBcmVNaW5pZmllZChzb3VyY2VDb2RlIHx8ICcnKSxcclxuICAgICAgaXNJbk5vZGVNb2R1bGVzOiBGaWxlQ2hhbmdlZENhY2hlLmlzSW5Ob2RlTW9kdWxlcyhhYnNvbHV0ZUZpbGVQYXRoKSxcclxuICAgICAgaGFzU291cmNlTWFwOiBGaWxlQ2hhbmdlZENhY2hlLmhhc1NvdXJjZU1hcChzb3VyY2VDb2RlIHx8ICcnKSxcclxuICAgICAgaXNGaWxlQmluYXJ5OiAhIWJpbmFyeURhdGFcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV0gPSB7IGN0aW1lLCBzaXplLCBpbmZvIH07XHJcbiAgICBkKGBDYWNoZSBlbnRyeSBmb3IgJHtjYWNoZUtleX06ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV0pfWApO1xyXG5cclxuICAgIGlmIChiaW5hcnlEYXRhKSB7XHJcbiAgICAgIHJldHVybiBfLmV4dGVuZCh7YmluYXJ5RGF0YX0sIGluZm8pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHtzb3VyY2VDb2RlfSwgaW5mbyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBkYXRhIHRoYXQgY2FuIHBhc3NlZCB0byB7QGxpbmsgbG9hZEZyb21EYXRhfSB0byByZWh5ZHJhdGUgdGhpcyBjYWNoZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRTYXZlZERhdGEoKSB7XHJcbiAgICByZXR1cm4geyBjaGFuZ2VDYWNoZTogdGhpcy5jaGFuZ2VDYWNoZSwgYXBwUm9vdDogdGhpcy5hcHBSb290IH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXJpYWxpemVzIHRoaXMgb2JqZWN0J3MgZGF0YSB0byBhIGZpbGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGggIFRoZSBwYXRoIHRvIHNhdmUgZGF0YSB0by5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IENvbXBsZXRpb24uXHJcbiAgICovXHJcbiAgYXN5bmMgc2F2ZShmaWxlUGF0aCkge1xyXG4gICAgbGV0IHRvU2F2ZSA9IHRoaXMuZ2V0U2F2ZWREYXRhKCk7XHJcblxyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHB6bGliLmd6aXAobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh0b1NhdmUpKSk7XHJcbiAgICBhd2FpdCBwZnMud3JpdGVGaWxlKGZpbGVQYXRoLCBidWYpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY2FsY3VsYXRlSGFzaEZvckZpbGUoYWJzb2x1dGVGaWxlUGF0aCkge1xyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZShhYnNvbHV0ZUZpbGVQYXRoKTtcclxuICAgIGxldCBlbmNvZGluZyA9IEZpbGVDaGFuZ2VkQ2FjaGUuZGV0ZWN0RmlsZUVuY29kaW5nKGJ1Zik7XHJcblxyXG4gICAgaWYgKCFlbmNvZGluZykge1xyXG4gICAgICBsZXQgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnVmKS5kaWdlc3QoJ2hleCcpO1xyXG4gICAgICByZXR1cm4geyBzb3VyY2VDb2RlOiBudWxsLCBkaWdlc3QsIGJpbmFyeURhdGE6IGJ1ZiB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzb3VyY2VDb2RlID0gYXdhaXQgcGZzLnJlYWRGaWxlKGFic29sdXRlRmlsZVBhdGgsIGVuY29kaW5nKTtcclxuICAgIGxldCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzb3VyY2VDb2RlLCAndXRmOCcpLmRpZ2VzdCgnaGV4Jyk7XHJcblxyXG4gICAgcmV0dXJuIHtzb3VyY2VDb2RlLCBkaWdlc3QsIGJpbmFyeURhdGE6IG51bGwgfTtcclxuICB9XHJcblxyXG4gIGdldEhhc2hGb3JQYXRoU3luYyhhYnNvbHV0ZUZpbGVQYXRoKSB7XHJcbiAgICBsZXQgY2FjaGVLZXkgPSBzYW5pdGl6ZUZpbGVQYXRoKGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgaWYgKHRoaXMuYXBwUm9vdCkge1xyXG4gICAgICBjYWNoZUtleSA9IGNhY2hlS2V5LnJlcGxhY2UodGhpcy5hcHBSb290LCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTkI6IFdlIGRvIHRoaXMgYmVjYXVzZSB4LXJlcXVpcmUgd2lsbCBpbmNsdWRlIGFuIGFic29sdXRlIHBhdGggZnJvbSB0aGVcclxuICAgIC8vIG9yaWdpbmFsIGJ1aWx0IGFwcCBhbmQgd2UgbmVlZCB0byBzdGlsbCBncm9rIGl0XHJcbiAgICBpZiAodGhpcy5vcmlnaW5hbEFwcFJvb3QpIHtcclxuICAgICAgY2FjaGVLZXkgPSBjYWNoZUtleS5yZXBsYWNlKHRoaXMub3JpZ2luYWxBcHBSb290LCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucmVhbEFwcFJvb3QpIHtcclxuICAgICAgY2FjaGVLZXkgPSBjYWNoZUtleS5yZXBsYWNlKHRoaXMucmVhbEFwcFJvb3QsICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGVFbnRyeSA9IHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldO1xyXG5cclxuICAgIGlmICh0aGlzLmZhaWxPbkNhY2hlTWlzcykge1xyXG4gICAgICBpZiAoIWNhY2hlRW50cnkpIHtcclxuICAgICAgICBkKGBUcmllZCB0byByZWFkIGZpbGUgY2FjaGUgZW50cnkgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH1gKTtcclxuICAgICAgICBkKGBjYWNoZUtleTogJHtjYWNoZUtleX0sIGFwcFJvb3Q6ICR7dGhpcy5hcHBSb290fSwgb3JpZ2luYWxBcHBSb290OiAke3RoaXMub3JpZ2luYWxBcHBSb290fWApO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH0gYnV0IGl0IHdhcyBub3QgcHJlY29tcGlsZWQhYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZm87XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHN0YXQgPSBmcy5zdGF0U3luYyhhYnNvbHV0ZUZpbGVQYXRoKTtcclxuICAgIGxldCBjdGltZSA9IHN0YXQuY3RpbWUuZ2V0VGltZSgpO1xyXG4gICAgbGV0IHNpemUgPSBzdGF0LnNpemU7XHJcbiAgICBpZiAoIXN0YXQgfHwgIXN0YXQuaXNGaWxlKCkpIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3RhdCAke2Fic29sdXRlRmlsZVBhdGh9YCk7XHJcblxyXG4gICAgaWYgKGNhY2hlRW50cnkpIHtcclxuICAgICAgaWYgKGNhY2hlRW50cnkuY3RpbWUgPj0gY3RpbWUgJiYgY2FjaGVFbnRyeS5zaXplID09PSBzaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkuaW5mbztcclxuICAgICAgfVxyXG5cclxuICAgICAgZChgSW52YWxpZGF0aW5nIGNhY2hlIGVudHJ5OiAke2NhY2hlRW50cnkuY3RpbWV9ID09PSAke2N0aW1lfSAmJiAke2NhY2hlRW50cnkuc2l6ZX0gPT09ICR7c2l6ZX1gKTtcclxuICAgICAgZGVsZXRlIHRoaXMuY2hhbmdlQ2FjaGUuY2FjaGVFbnRyeTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQge2RpZ2VzdCwgc291cmNlQ29kZSwgYmluYXJ5RGF0YX0gPSB0aGlzLmNhbGN1bGF0ZUhhc2hGb3JGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoKTtcclxuXHJcbiAgICBsZXQgaW5mbyA9IHtcclxuICAgICAgaGFzaDogZGlnZXN0LFxyXG4gICAgICBpc01pbmlmaWVkOiBGaWxlQ2hhbmdlZENhY2hlLmNvbnRlbnRzQXJlTWluaWZpZWQoc291cmNlQ29kZSB8fCAnJyksXHJcbiAgICAgIGlzSW5Ob2RlTW9kdWxlczogRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoYWJzb2x1dGVGaWxlUGF0aCksXHJcbiAgICAgIGhhc1NvdXJjZU1hcDogRmlsZUNoYW5nZWRDYWNoZS5oYXNTb3VyY2VNYXAoc291cmNlQ29kZSB8fCAnJyksXHJcbiAgICAgIGlzRmlsZUJpbmFyeTogISFiaW5hcnlEYXRhXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldID0geyBjdGltZSwgc2l6ZSwgaW5mbyB9O1xyXG4gICAgZChgQ2FjaGUgZW50cnkgZm9yICR7Y2FjaGVLZXl9OiAke0pTT04uc3RyaW5naWZ5KHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldKX1gKTtcclxuXHJcbiAgICBpZiAoYmluYXJ5RGF0YSkge1xyXG4gICAgICByZXR1cm4gXy5leHRlbmQoe2JpbmFyeURhdGF9LCBpbmZvKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBfLmV4dGVuZCh7c291cmNlQ29kZX0sIGluZm8pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2F2ZVN5bmMoZmlsZVBhdGgpIHtcclxuICAgIGxldCB0b1NhdmUgPSB0aGlzLmdldFNhdmVkRGF0YSgpO1xyXG5cclxuICAgIGxldCBidWYgPSB6bGliLmd6aXBTeW5jKG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkodG9TYXZlKSkpO1xyXG4gICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgYnVmKTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZUhhc2hGb3JGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoKSB7XHJcbiAgICBsZXQgYnVmID0gZnMucmVhZEZpbGVTeW5jKGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgbGV0IGVuY29kaW5nID0gRmlsZUNoYW5nZWRDYWNoZS5kZXRlY3RGaWxlRW5jb2RpbmcoYnVmKTtcclxuXHJcbiAgICBpZiAoIWVuY29kaW5nKSB7XHJcbiAgICAgIGxldCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShidWYpLmRpZ2VzdCgnaGV4Jyk7XHJcbiAgICAgIHJldHVybiB7IHNvdXJjZUNvZGU6IG51bGwsIGRpZ2VzdCwgYmluYXJ5RGF0YTogYnVmfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgc291cmNlQ29kZSA9IGZzLnJlYWRGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoLCBlbmNvZGluZyk7XHJcbiAgICBsZXQgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoc291cmNlQ29kZSwgJ3V0ZjgnKS5kaWdlc3QoJ2hleCcpO1xyXG5cclxuICAgIHJldHVybiB7c291cmNlQ29kZSwgZGlnZXN0LCBiaW5hcnlEYXRhOiBudWxsfTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHZpYSBzb21lIHN0YXRpc3RpY3Mgd2hldGhlciBhIGZpbGUgaXMgbGlrZWx5IHRvIGJlIG1pbmlmaWVkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgY29udGVudHNBcmVNaW5pZmllZChzb3VyY2UpIHtcclxuICAgIGxldCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xyXG4gICAgaWYgKGxlbmd0aCA+IDEwMjQpIGxlbmd0aCA9IDEwMjQ7XHJcblxyXG4gICAgbGV0IG5ld2xpbmVDb3VudCA9IDA7XHJcblxyXG4gICAgLy8gUm9sbCB0aHJvdWdoIHRoZSBjaGFyYWN0ZXJzIGFuZCBkZXRlcm1pbmUgdGhlIGF2ZXJhZ2UgbGluZSBsZW5ndGhcclxuICAgIGZvcihsZXQgaT0wOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChzb3VyY2VbaV0gPT09ICdcXG4nKSBuZXdsaW5lQ291bnQrKztcclxuICAgIH1cclxuXHJcbiAgICAvLyBObyBOZXdsaW5lcz8gQW55IGZpbGUgb3RoZXIgdGhhbiBhIHN1cGVyIHNtYWxsIG9uZSBpcyBtaW5pZmllZFxyXG4gICAgaWYgKG5ld2xpbmVDb3VudCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gKGxlbmd0aCA+IDgwKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgYXZnTGluZUxlbmd0aCA9IGxlbmd0aCAvIG5ld2xpbmVDb3VudDtcclxuICAgIHJldHVybiAoYXZnTGluZUxlbmd0aCA+IDgwKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBwYXRoIGlzIGluIG5vZGVfbW9kdWxlcyBvciB0aGUgRWxlY3Ryb24gaW5pdCBjb2RlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBpc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpIHtcclxuICAgIHJldHVybiAhIShmaWxlUGF0aC5tYXRjaCgvKG5vZGVfbW9kdWxlc3xib3dlcl9jb21wb25lbnRzKVtcXFxcXFwvXS9pKSB8fCBmaWxlUGF0aC5tYXRjaCgvKGF0b218ZWxlY3Ryb24pXFwuYXNhci8pKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBmaWxlIGhhcyBhbiBpbmxpbmUgc291cmNlIG1hcFxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgaGFzU291cmNlTWFwKHNvdXJjZUNvZGUpIHtcclxuICAgIGNvbnN0IHRyaW1tZWQgPSBzb3VyY2VDb2RlLnRyaW0oKTtcclxuICAgIHJldHVybiB0cmltbWVkLmxhc3RJbmRleE9mKCcvLyMgc291cmNlTWFwJykgPiB0cmltbWVkLmxhc3RJbmRleE9mKCdcXG4nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgdGhlIGVuY29kaW5nIG9mIGEgZmlsZSBmcm9tIHRoZSB0d28gbW9zdCBjb21tb24gZW5jb2RpbmdzIGJ5IHRyeWluZ1xyXG4gICAqIHRvIGRlY29kZSBpdCB0aGVuIGxvb2tpbmcgZm9yIGVuY29kaW5nIGVycm9yc1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgZGV0ZWN0RmlsZUVuY29kaW5nKGJ1ZmZlcikge1xyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAxKSByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgYnVmID0gKGJ1ZmZlci5sZW5ndGggPCA0MDk2ID8gYnVmZmVyIDogYnVmZmVyLnNsaWNlKDAsIDQwOTYpKTtcclxuXHJcbiAgICBjb25zdCBlbmNvZGluZ3MgPSBbJ3V0ZjgnLCAndXRmMTZsZSddO1xyXG5cclxuICAgIGxldCBlbmNvZGluZyA9IF8uZmluZChcclxuICAgICAgZW5jb2RpbmdzLFxyXG4gICAgICAoeCkgPT4gIUZpbGVDaGFuZ2VkQ2FjaGUuY29udGFpbnNDb250cm9sQ2hhcmFjdGVycyhidWYudG9TdHJpbmcoeCkpKTtcclxuXHJcbiAgICByZXR1cm4gZW5jb2Rpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgaXMgbGlrZWx5IHRvIGJlIHBvb3JseSBlbmNvZGVkIGJ5IGxvb2tpbmcgZm9yXHJcbiAgICogY29udHJvbCBjaGFyYWN0ZXJzIGFib3ZlIGEgY2VydGFpbiB0aHJlc2hvbGRcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNvbnRhaW5zQ29udHJvbENoYXJhY3RlcnMoc3RyKSB7XHJcbiAgICBsZXQgY29udHJvbENvdW50ID0gMDtcclxuICAgIGxldCBzcGFjZUNvdW50ID0gMDtcclxuICAgIGxldCB0aHJlc2hvbGQgPSAyO1xyXG4gICAgaWYgKHN0ci5sZW5ndGggPiA2NCkgdGhyZXNob2xkID0gNDtcclxuICAgIGlmIChzdHIubGVuZ3RoID4gNTEyKSB0aHJlc2hvbGQgPSA4O1xyXG5cclxuICAgIGZvciAobGV0IGk9MDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICBpZiAoYyA9PT0gNjU1MzYgfHwgYyA8IDgpIGNvbnRyb2xDb3VudCsrO1xyXG4gICAgICBpZiAoYyA+IDE0ICYmIGMgPCAzMikgY29udHJvbENvdW50Kys7XHJcbiAgICAgIGlmIChjID09PSAzMikgc3BhY2VDb3VudCsrO1xyXG5cclxuICAgICAgaWYgKGNvbnRyb2xDb3VudCA+IHRocmVzaG9sZCkgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNwYWNlQ291bnQgPCB0aHJlc2hvbGQpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIGlmIChjb250cm9sQ291bnQgPT09IDApIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiAoY29udHJvbENvdW50IC8gc3RyLmxlbmd0aCkgPCAwLjAyO1xyXG4gIH1cclxufVxyXG4iXX0=