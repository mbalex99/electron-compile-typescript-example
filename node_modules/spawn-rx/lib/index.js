'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findActualExecutable = findActualExecutable;
exports.spawnDetached = spawnDetached;
exports.spawn = spawn;
exports.spawnDetachedPromise = spawnDetachedPromise;
exports.spawnPromise = spawnPromise;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _rx = require('rx');

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var spawnOg = require('child_process').spawn;
var isWindows = process.platform === 'win32';

var d = require('debug')('surf:promise-array');

/**
 * stat a file but don't throw if it doesn't exist
 *
 * @param  {string} file The path to a file
 * @return {Stats}       The stats structure
 *
 * @private
 */
function statSyncNoException(file) {
  try {
    return _fs2.default.statSync(file);
  } catch (e) {
    return null;
  }
}

/**
 * Search PATH to see if a file exists in any of the path folders.
 *
 * @param  {string} exe The file to search for
 * @return {string}     A fully qualified path, or the original path if nothing
 *                      is found
 *
 * @private
 */
function runDownPath(exe) {
  // NB: Windows won't search PATH looking for executables in spawn like
  // Posix does

  // Files with any directory path don't get this applied
  if (exe.match(/[\\\/]/)) {
    d('Path has slash in directory, bailing');
    return exe;
  }

  var target = _path2.default.join('.', exe);
  if (statSyncNoException(target)) {
    d('Found executable in currect directory: ' + target);
    return target;
  }

  var haystack = process.env.PATH.split(isWindows ? ';' : ':');
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = haystack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var p = _step.value;

      var needle = _path2.default.join(p, exe);
      if (statSyncNoException(needle)) return needle;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  d('Failed to find executable anywhere in path');
  return exe;
}

/**
 * Finds the actual executable and parameters to run on Windows. This method
 * mimics the POSIX behavior of being able to run scripts as executables by
 * replacing the passed-in executable with the script runner, for PowerShell,
 * CMD, and node scripts.
 *
 * This method also does the work of running down PATH, which spawn on Windows
 * also doesn't do, unlike on POSIX.
 *
 * @param  {string} exe           The executable to run
 * @param  {Array<string>} args   The arguments to run
 *
 * @return {Object}               The cmd and args to run
 * @property {string} cmd         The command to pass to spawn
 * @property {Array<string>} args The arguments to pass to spawn
 */
function findActualExecutable(exe, args) {
  // POSIX can just execute scripts directly, no need for silly goosery
  if (process.platform !== 'win32') return { cmd: runDownPath(exe), args: args };

  if (!_fs2.default.existsSync(exe)) {
    // NB: When you write something like `surf-client ... -- surf-build` on Windows,
    // a shell would normally convert that to surf-build.cmd, but since it's passed
    // in as an argument, it doesn't happen
    var possibleExts = ['.exe', '.bat', '.cmd', '.ps1'];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = possibleExts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var ext = _step2.value;

        var possibleFullPath = runDownPath('' + exe + ext);

        if (_fs2.default.existsSync(possibleFullPath)) {
          return findActualExecutable(possibleFullPath, args);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  if (exe.match(/\.ps1$/i)) {
    var cmd = _path2.default.join(process.env.SYSTEMROOT, 'System32', 'WindowsPowerShell', 'v1.0', 'PowerShell.exe');
    var psargs = ['-ExecutionPolicy', 'Unrestricted', '-NoLogo', '-NonInteractive', '-File', exe];

    return { cmd: cmd, args: psargs.concat(args) };
  }

  if (exe.match(/\.(bat|cmd)$/i)) {
    var _cmd = _path2.default.join(process.env.SYSTEMROOT, 'System32', 'cmd.exe');
    var cmdArgs = ['/C', exe + ' ' + args.join(' ')];

    return { cmd: _cmd, args: cmdArgs };
  }

  if (exe.match(/\.(js)$/i)) {
    var _cmd2 = process.execPath;
    var nodeArgs = [exe];

    return { cmd: _cmd2, args: nodeArgs.concat(args) };
  }

  // Dunno lol
  return { cmd: exe, args: args };
}

/**
 * Spawns a process but detached from the current process. The process is put
 * into its own Process Group that can be killed by unsubscribing from the
 * return Observable.
 *
 * @param  {string} exe               The executable to run
 * @param  {Array<string>} params     The parameters to pass to the child
 * @param  {Object} opts              Options to pass to spawn.
 *
 * @return {Observable<string>}       Returns an Observable that when subscribed
 *                                    to, will create a detached process. The
 *                                    process output will be streamed to this
 *                                    Observable, and if unsubscribed from, the
 *                                    process will be terminated early. If the
 *                                    process terminates with a non-zero value,
 *                                    the Observable will terminate with onError.
 */
function spawnDetached(exe, params) {
  var opts = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var _findActualExecutable = findActualExecutable(exe, params);

  var cmd = _findActualExecutable.cmd;
  var args = _findActualExecutable.args;


  if (!isWindows) return spawn(cmd, args, _lodash2.default.assign({}, opts || {}, { detached: true }));
  var newParams = [cmd].concat(args);

  var target = _path2.default.join(__dirname, '..', 'vendor', 'jobber', 'jobber.exe');
  var options = _lodash2.default.assign({}, opts || {}, { detached: true, jobber: true });

  d('spawnDetached: ' + target + ', ' + newParams);
  return spawn(target, newParams, options);
}

/**
 * Spawns a process attached as a child of the current process.
 *
 * @param  {string} exe               The executable to run
 * @param  {Array<string>} params     The parameters to pass to the child
 * @param  {Object} opts              Options to pass to spawn.
 *
 * @return {Observable<string>}       Returns an Observable that when subscribed
 *                                    to, will create a child process. The
 *                                    process output will be streamed to this
 *                                    Observable, and if unsubscribed from, the
 *                                    process will be terminated early. If the
 *                                    process terminates with a non-zero value,
 *                                    the Observable will terminate with onError.
 */
function spawn(exe) {
  var params = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var opts = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var spawnObs = _rx.Observable.create(function (subj) {
    var proc = null;

    var _findActualExecutable2 = findActualExecutable(exe, params);

    var cmd = _findActualExecutable2.cmd;
    var args = _findActualExecutable2.args;

    if (!opts) {
      d('spawning process: ' + cmd + ' ' + args.join());
      proc = spawnOg(cmd, args);
    } else {
      d('spawning process: ' + cmd + ' ' + args.join() + ', ' + JSON.stringify(opts));
      proc = spawnOg(cmd, args, _lodash2.default.omit(opts, 'jobber'));
    }

    var bufHandler = function bufHandler(b) {
      if (b.length < 1) return;
      var chunk = "<< String sent back was too long >>";
      try {
        chunk = b.toString();
      } catch (e) {
        chunk = '<< Lost chunk of process output for ' + exe + ' - length was ' + b.length + '>>';
      }

      subj.onNext(chunk);
    };

    var stderrCompleted = null;
    var stdoutCompleted = null;
    var noClose = false;

    if (proc.stdout) {
      stdoutCompleted = new _rx.AsyncSubject();
      proc.stdout.on('data', bufHandler);
      proc.stdout.on('close', function () {
        stdoutCompleted.onNext(true);stdoutCompleted.onCompleted();
      });
    } else {
      stdoutCompleted = _rx.Observable.just(true);
    }

    if (proc.stderr) {
      stderrCompleted = new _rx.AsyncSubject();
      proc.stderr.on('data', bufHandler);
      proc.stderr.on('close', function () {
        stderrCompleted.onNext(true);stderrCompleted.onCompleted();
      });
    } else {
      stderrCompleted = _rx.Observable.just(true);
    }

    proc.on('error', function (e) {
      noClose = true;
      subj.onError(e);
    });

    proc.on('close', function (code) {
      noClose = true;
      var pipesClosed = _rx.Observable.merge(stdoutCompleted, stderrCompleted).reduce(function (acc) {
        return acc;
      }, true);

      if (code === 0) {
        pipesClosed.subscribe(function () {
          return subj.onCompleted();
        });
      } else {
        pipesClosed.subscribe(function () {
          return subj.onError(new Error('Failed with exit code: ' + code));
        });
      }
    });

    return _rx.Disposable.create(function () {
      if (noClose) return;

      d('Killing process: ' + cmd + ' ' + args.join());
      if (!opts.jobber) {
        proc.kill();
        return;
      }

      // NB: Connecting to Jobber's named pipe will kill it
      _net2.default.connect('\\\\.\\pipe\\jobber-' + proc.pid);
      setTimeout(function () {
        return proc.kill();
      }, 5 * 1000);
    });
  });

  return spawnObs;
}

function wrapObservableInPromise(obs) {
  return new Promise(function (res, rej) {
    var out = '';

    obs.subscribe(function (x) {
      return out += x;
    }, function (e) {
      return rej(new Error(out + '\n' + e.message));
    }, function () {
      return res(out);
    });
  });
}

/**
 * Spawns a process but detached from the current process. The process is put
 * into its own Process Group.
 *
 * @param  {string} exe               The executable to run
 * @param  {Array<string>} params     The parameters to pass to the child
 * @param  {Object} opts              Options to pass to spawn.
 *
 * @return {Promise<string>}       Returns an Promise that represents a detached
 *                                 process. The value returned is the process
 *                                 output. If the process terminates with a
 *                                 non-zero value, the Promise will resolve with
 *                                 an Error.
 */
function spawnDetachedPromise(exe, params) {
  var opts = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  return wrapObservableInPromise(spawnDetached(exe, params, opts));
}

/**
 * Spawns a process as a child process.
 *
 * @param  {string} exe               The executable to run
 * @param  {Array<string>} params     The parameters to pass to the child
 * @param  {Object} opts              Options to pass to spawn.
 *
 * @return {Promise<string>}       Returns an Promise that represents a child
 *                                 process. The value returned is the process
 *                                 output. If the process terminates with a
 *                                 non-zero value, the Promise will resolve with
 *                                 an Error.
 */
function spawnPromise(exe, params) {
  var opts = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  return wrapObservableInPromise(spawn(exe, params, opts));
}