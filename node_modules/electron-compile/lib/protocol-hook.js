'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

exports.rigHtmlDocumentToInitializeElectronCompile = rigHtmlDocumentToInitializeElectronCompile;
exports.initializeProtocolHook = initializeProtocolHook;

require('./babel-maybefill');

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _mimeTypes = require('@paulcbetts/mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var magicWords = "__magic__file__to__help__electron__compile.js";

// NB: These are duped in initialize-renderer so we can save startup time, make
// sure to run both!
var magicGlobalForRootCacheDir = '__electron_compile_root_cache_dir';
var magicGlobalForAppRootDir = '__electron_compile_app_root_dir';

var d = require('debug')('electron-compile:protocol-hook');

var protocol = null;

/**
 * Adds our script header to the top of all HTML files
 *
 * @private
 */
function rigHtmlDocumentToInitializeElectronCompile(doc) {
  var lines = doc.split("\n");
  var replacement = '<head><script src="' + magicWords + '"></script>';
  var replacedHead = false;

  for (var i = 0; i < lines.length; i++) {
    if (!lines[i].match(/<head>/i)) continue;

    lines[i] = lines[i].replace(/<head>/i, replacement);
    replacedHead = true;
    break;
  }

  if (!replacedHead) {
    replacement = '<html$1><head><script src="' + magicWords + '"></script></head>';
    for (var _i = 0; _i < lines.length; _i++) {
      if (!lines[_i].match(/<html/i)) continue;

      lines[_i] = lines[_i].replace(/<html([^>]+)>/i, replacement);
      break;
    }
  }

  return lines.join("\n");
}

function requestFileJob(filePath, finish) {
  _fs2.default.readFile(filePath, function (err, buf) {
    if (err) {
      if (err.errno === 34) {
        finish(-6); // net::ERR_FILE_NOT_FOUND
        return;
      } else {
        finish(-2); // net::FAILED
        return;
      }
    }

    finish({
      data: buf,
      mimeType: _mimeTypes2.default.lookup(filePath) || 'text/plain'
    });
  });
}

/**
 * Initializes the protocol hook on file: that allows us to intercept files
 * loaded by Chromium and rewrite them. This method along with
 * {@link registerRequireExtension} are the top-level methods that electron-compile
 * actually uses to intercept code that Electron loads.
 *
 * @param  {CompilerHost} compilerHost  The compiler host to use for compilation.
 */
function initializeProtocolHook(compilerHost) {
  protocol = protocol || require('electron').protocol;

  global[magicGlobalForRootCacheDir] = compilerHost.rootCacheDir;
  global[magicGlobalForAppRootDir] = compilerHost.appRoot;

  var electronCompileSetupCode = 'if (window.require) require(\'electron-compile/lib/initialize-renderer\').initializeRendererProcess(' + compilerHost.readOnlyMode + ');';

  protocol.interceptBufferProtocol('file', function () {
    var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(request, finish) {
      var uri, filePath, _ret, result, err;

      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              uri = _url2.default.parse(request.url);


              d('Intercepting url ' + request.url);

              if (!(request.url.indexOf(magicWords) > -1)) {
                _context.next = 5;
                break;
              }

              finish({
                mimeType: 'application/javascript',
                data: new Buffer(electronCompileSetupCode, 'utf8')
              });

              return _context.abrupt('return');

            case 5:
              if (!(uri.host && uri.host.length > 1)) {
                _context.next = 9;
                break;
              }

              //let newUri = request.url.replace(/^file:/, "https:");
              // TODO: Jump off this bridge later
              d('TODO: Found bogus protocol-relative URL, can\'t fix it up!!');
              finish(-2);
              return _context.abrupt('return');

            case 9:
              filePath = decodeURIComponent(uri.pathname);

              // NB: pathname has a leading '/' on Win32 for some reason

              if (process.platform === 'win32') {
                filePath = filePath.slice(1);
              }

              // NB: Special-case files coming from atom.asar or node_modules

              if (!(filePath.match(/[\/\\](atom|electron).asar/) || filePath.match(/[\/\\](node_modules|bower_components)/))) {
                _context.next = 18;
                break;
              }

              if (!filePath.match(/\.html?$/i)) {
                _context.next = 16;
                break;
              }

              _ret = function () {
                var riggedContents = null;
                _fs2.default.readFile(filePath, 'utf8', function (err, contents) {
                  if (err) {
                    if (err.errno === 34) {
                      finish(-6); // net::ERR_FILE_NOT_FOUND
                      return;
                    } else {
                      finish(-2); // net::FAILED
                      return;
                    }
                  }

                  riggedContents = rigHtmlDocumentToInitializeElectronCompile(contents);
                  finish({ data: new Buffer(riggedContents), mimeType: 'text/html' });
                  return;
                });

                return {
                  v: void 0
                };
              }();

              if (!((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object")) {
                _context.next = 16;
                break;
              }

              return _context.abrupt('return', _ret.v);

            case 16:

              requestFileJob(filePath, finish);
              return _context.abrupt('return');

            case 18:
              _context.prev = 18;
              _context.next = 21;
              return compilerHost.compile(filePath);

            case 21:
              result = _context.sent;


              if (result.mimeType === 'text/html') {
                result.code = rigHtmlDocumentToInitializeElectronCompile(result.code);
              }

              if (!(result.binaryData || result.code instanceof Buffer)) {
                _context.next = 28;
                break;
              }

              finish({ data: result.binaryData || result.code, mimeType: result.mimeType });
              return _context.abrupt('return');

            case 28:
              finish({ data: new Buffer(result.code), mimeType: result.mimeType });
              return _context.abrupt('return');

            case 30:
              _context.next = 41;
              break;

            case 32:
              _context.prev = 32;
              _context.t0 = _context['catch'](18);
              err = 'Failed to compile ' + filePath + ': ' + _context.t0.message + '\n' + _context.t0.stack;

              d(err);

              if (!(_context.t0.errno === 34 /*ENOENT*/)) {
                _context.next = 39;
                break;
              }

              finish(-6); // net::ERR_FILE_NOT_FOUND
              return _context.abrupt('return');

            case 39:

              finish({ mimeType: 'text/plain', data: new Buffer(err) });
              return _context.abrupt('return');

            case 41:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this, [[18, 32]]);
    }));
    return function (_x, _x2) {
      return ref.apply(this, arguments);
    };
  }());
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm90b2NvbC1ob29rLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQXNCZ0IsMEMsR0FBQSwwQztRQXFEQSxzQixHQUFBLHNCOztBQTNFaEI7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNLGFBQWEsK0NBQW5COzs7O0FBSUEsSUFBTSw2QkFBNkIsbUNBQW5DO0FBQ0EsSUFBTSwyQkFBMkIsaUNBQWpDOztBQUVBLElBQU0sSUFBSSxRQUFRLE9BQVIsRUFBaUIsZ0NBQWpCLENBQVY7O0FBRUEsSUFBSSxXQUFXLElBQWY7Ozs7Ozs7QUFPTyxTQUFTLDBDQUFULENBQW9ELEdBQXBELEVBQXlEO0FBQzlELE1BQUksUUFBUSxJQUFJLEtBQUosQ0FBVSxJQUFWLENBQVo7QUFDQSxNQUFJLHNDQUFvQyxVQUFwQyxnQkFBSjtBQUNBLE1BQUksZUFBZSxLQUFuQjs7QUFFQSxPQUFLLElBQUksSUFBRSxDQUFYLEVBQWMsSUFBSSxNQUFNLE1BQXhCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ25DLFFBQUksQ0FBQyxNQUFNLENBQU4sRUFBUyxLQUFULENBQWUsU0FBZixDQUFMLEVBQWdDOztBQUVoQyxVQUFNLENBQU4sSUFBWSxNQUFNLENBQU4sQ0FBRCxDQUFXLE9BQVgsQ0FBbUIsU0FBbkIsRUFBOEIsV0FBOUIsQ0FBWDtBQUNBLG1CQUFlLElBQWY7QUFDQTtBQUNEOztBQUVELE1BQUksQ0FBQyxZQUFMLEVBQW1CO0FBQ2pCLGtEQUE0QyxVQUE1QztBQUNBLFNBQUssSUFBSSxLQUFFLENBQVgsRUFBYyxLQUFJLE1BQU0sTUFBeEIsRUFBZ0MsSUFBaEMsRUFBcUM7QUFDbkMsVUFBSSxDQUFDLE1BQU0sRUFBTixFQUFTLEtBQVQsQ0FBZSxRQUFmLENBQUwsRUFBK0I7O0FBRS9CLFlBQU0sRUFBTixJQUFZLE1BQU0sRUFBTixDQUFELENBQVcsT0FBWCxDQUFtQixnQkFBbkIsRUFBcUMsV0FBckMsQ0FBWDtB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TUFBekI7QUF2RHFDOztBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQTREbEIsYUFBYSxPQUFiLENBQXFCLFFBQXJCLENBNURrQjs7QUFBQTtBQTREakMsb0JBNURpQzs7O0FBOERyQyxrQkFBSSxPQUFPLFFBQVAsS0FBb0IsV0FBeEIsRUFBcUM7QUFDbkMsdUJBQU8sSUFBUCxHQUFjLDJDQUEyQyxPQUFPLElBQWxELENBQWQ7QUFDRDs7QUFoRW9DLG9CQWtFakMsT0FBTyxVQUFQLElBQXFCLE9BQU8sSUFBUCxZQUF1QixNQWxFWDtBQUFBO0FBQUE7QUFBQTs7QUFtRW5DLHFCQUFPLEVBQUUsTUFBTSxPQUFPLFVBQVAsSUFBcUIsT0FBTyxJQUFwQyxFQUEwQyxVQUFVLE9BQU8sUUFBM0QsRUFBUDtBQW5FbUM7O0FBQUE7QUFzRW5DLHFCQUFPLEVBQUUsTUFBTSxJQUFJLE1BQUosQ0FBVyxPQUFPLElBQWxCLENBQVIsRUFBaUMsVUFBVSxPQUFPLFFBQWxELEVBQVA7QUF0RW1DOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUEwRWpDLGlCQTFFaUMsMEJBMEVOLFFBMUVNLFVBMEVPLFlBQUUsT0ExRVQsVUEwRXFCLFlBQUUsS0ExRXZCOztBQTJFckMsZ0JBQUUsR0FBRjs7QUEzRXFDLG9CQTZFakMsWUFBRSxLQUFGLEtBQVksRSxXQTdFcUI7QUFBQTtBQUFBO0FBQUE7O0FBOEVuQyxxQkFBTyxDQUFDLENBQVIsRTtBQTlFbUM7O0FBQUE7O0FBa0ZyQyxxQkFBTyxFQUFFLFVBQVUsWUFBWixFQUEwQixNQUFNLElBQUksTUFBSixDQUFXLEdBQVgsQ0FBaEMsRUFBUDtBQWxGcUM7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBekM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXNGRCIsImZpbGUiOiJwcm90b2NvbC1ob29rLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuL2JhYmVsLW1heWJlZmlsbCc7XHJcblxyXG5pbXBvcnQgdXJsIGZyb20gJ3VybCc7XHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBtaW1lIGZyb20gJ0BwYXVsY2JldHRzL21pbWUtdHlwZXMnO1xyXG5cclxuY29uc3QgbWFnaWNXb3JkcyA9IFwiX19tYWdpY19fZmlsZV9fdG9fX2hlbHBfX2VsZWN0cm9uX19jb21waWxlLmpzXCI7XHJcblxyXG4vLyBOQjogVGhlc2UgYXJlIGR1cGVkIGluIGluaXRpYWxpemUtcmVuZGVyZXIgc28gd2UgY2FuIHNhdmUgc3RhcnR1cCB0aW1lLCBtYWtlXHJcbi8vIHN1cmUgdG8gcnVuIGJvdGghXHJcbmNvbnN0IG1hZ2ljR2xvYmFsRm9yUm9vdENhY2hlRGlyID0gJ19fZWxlY3Ryb25fY29tcGlsZV9yb290X2NhY2hlX2Rpcic7XHJcbmNvbnN0IG1hZ2ljR2xvYmFsRm9yQXBwUm9vdERpciA9ICdfX2VsZWN0cm9uX2NvbXBpbGVfYXBwX3Jvb3RfZGlyJztcclxuXHJcbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOnByb3RvY29sLWhvb2snKTtcclxuXHJcbmxldCBwcm90b2NvbCA9IG51bGw7XHJcblxyXG4vKipcclxuICogQWRkcyBvdXIgc2NyaXB0IGhlYWRlciB0byB0aGUgdG9wIG9mIGFsbCBIVE1MIGZpbGVzXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmlnSHRtbERvY3VtZW50VG9Jbml0aWFsaXplRWxlY3Ryb25Db21waWxlKGRvYykge1xyXG4gIGxldCBsaW5lcyA9IGRvYy5zcGxpdChcIlxcblwiKTtcclxuICBsZXQgcmVwbGFjZW1lbnQgPSBgPGhlYWQ+PHNjcmlwdCBzcmM9XCIke21hZ2ljV29yZHN9XCI+PC9zY3JpcHQ+YDtcclxuICBsZXQgcmVwbGFjZWRIZWFkID0gZmFsc2U7XHJcblxyXG4gIGZvciAobGV0IGk9MDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoIWxpbmVzW2ldLm1hdGNoKC88aGVhZD4vaSkpIGNvbnRpbnVlO1xyXG5cclxuICAgIGxpbmVzW2ldID0gKGxpbmVzW2ldKS5yZXBsYWNlKC88aGVhZD4vaSwgcmVwbGFjZW1lbnQpO1xyXG4gICAgcmVwbGFjZWRIZWFkID0gdHJ1ZTtcclxuICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFyZXBsYWNlZEhlYWQpIHtcclxuICAgIHJlcGxhY2VtZW50ID0gYDxodG1sJDE+PGhlYWQ+PHNjcmlwdCBzcmM9XCIke21hZ2ljV29yZHN9XCI+PC9zY3JpcHQ+PC9oZWFkPmA7XHJcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoIWxpbmVzW2ldLm1hdGNoKC88aHRtbC9pKSkgY29udGludWU7XHJcblxyXG4gICAgICBsaW5lc1tpXSA9IChsaW5lc1tpXSkucmVwbGFjZSgvPGh0bWwoW14+XSspPi9pLCByZXBsYWNlbWVudCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcXVlc3RGaWxlSm9iKGZpbGVQYXRoLCBmaW5pc2gpIHtcclxuICBmcy5yZWFkRmlsZShmaWxlUGF0aCwgKGVyciwgYnVmKSA9PiB7XHJcbiAgICBpZiAoZXJyKSB7XHJcbiAgICAgIGlmIChlcnIuZXJybm8gPT09IDM0KSB7XHJcbiAgICAgICAgZmluaXNoKC02KTsgLy8gbmV0OjpFUlJfRklMRV9OT1RfRk9VTkRcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmluaXNoKC0yKTsgLy8gbmV0OjpGQUlMRURcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmaW5pc2goe1xyXG4gICAgICBkYXRhOiBidWYsXHJcbiAgICAgIG1pbWVUeXBlOiBtaW1lLmxvb2t1cChmaWxlUGF0aCkgfHwgJ3RleHQvcGxhaW4nXHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIHRoZSBwcm90b2NvbCBob29rIG9uIGZpbGU6IHRoYXQgYWxsb3dzIHVzIHRvIGludGVyY2VwdCBmaWxlc1xyXG4gKiBsb2FkZWQgYnkgQ2hyb21pdW0gYW5kIHJld3JpdGUgdGhlbS4gVGhpcyBtZXRob2QgYWxvbmcgd2l0aFxyXG4gKiB7QGxpbmsgcmVnaXN0ZXJSZXF1aXJlRXh0ZW5zaW9ufSBhcmUgdGhlIHRvcC1sZXZlbCBtZXRob2RzIHRoYXQgZWxlY3Ryb24tY29tcGlsZVxyXG4gKiBhY3R1YWxseSB1c2VzIHRvIGludGVyY2VwdCBjb2RlIHRoYXQgRWxlY3Ryb24gbG9hZHMuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0NvbXBpbGVySG9zdH0gY29tcGlsZXJIb3N0ICBUaGUgY29tcGlsZXIgaG9zdCB0byB1c2UgZm9yIGNvbXBpbGF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVQcm90b2NvbEhvb2soY29tcGlsZXJIb3N0KSB7XHJcbiAgcHJvdG9jb2wgPSBwcm90b2NvbCB8fCByZXF1aXJlKCdlbGVjdHJvbicpLnByb3RvY29sO1xyXG5cclxuICBnbG9iYWxbbWFnaWNHbG9iYWxGb3JSb290Q2FjaGVEaXJdID0gY29tcGlsZXJIb3N0LnJvb3RDYWNoZURpcjtcclxuICBnbG9iYWxbbWFnaWNHbG9iYWxGb3JBcHBSb290RGlyXSA9IGNvbXBpbGVySG9zdC5hcHBSb290O1xyXG5cclxuICBjb25zdCBlbGVjdHJvbkNvbXBpbGVTZXR1cENvZGUgPSBgaWYgKHdpbmRvdy5yZXF1aXJlKSByZXF1aXJlKCdlbGVjdHJvbi1jb21waWxlL2xpYi9pbml0aWFsaXplLXJlbmRlcmVyJykuaW5pdGlhbGl6ZVJlbmRlcmVyUHJvY2Vzcygke2NvbXBpbGVySG9zdC5yZWFkT25seU1vZGV9KTtgO1xyXG5cclxuICBwcm90b2NvbC5pbnRlcmNlcHRCdWZmZXJQcm90b2NvbCgnZmlsZScsIGFzeW5jIGZ1bmN0aW9uKHJlcXVlc3QsIGZpbmlzaCkge1xyXG4gICAgbGV0IHVyaSA9IHVybC5wYXJzZShyZXF1ZXN0LnVybCk7XHJcblxyXG4gICAgZChgSW50ZXJjZXB0aW5nIHVybCAke3JlcXVlc3QudXJsfWApO1xyXG4gICAgaWYgKHJlcXVlc3QudXJsLmluZGV4T2YobWFnaWNXb3JkcykgPiAtMSkge1xyXG4gICAgICBmaW5pc2goe1xyXG4gICAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXHJcbiAgICAgICAgZGF0YTogbmV3IEJ1ZmZlcihlbGVjdHJvbkNvbXBpbGVTZXR1cENvZGUsICd1dGY4JylcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBpcyBhIHByb3RvY29sLXJlbGF0aXZlIFVSTCB0aGF0IGhhcyBnb25lIHBlYXItc2hhcGVkIGluIEVsZWN0cm9uLFxyXG4gICAgLy8gbGV0J3MgcmV3cml0ZSBpdFxyXG4gICAgaWYgKHVyaS5ob3N0ICYmIHVyaS5ob3N0Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgLy9sZXQgbmV3VXJpID0gcmVxdWVzdC51cmwucmVwbGFjZSgvXmZpbGU6LywgXCJodHRwczpcIik7XHJcbiAgICAgIC8vIFRPRE86IEp1bXAgb2ZmIHRoaXMgYnJpZGdlIGxhdGVyXHJcbiAgICAgIGQoYFRPRE86IEZvdW5kIGJvZ3VzIHByb3RvY29sLXJlbGF0aXZlIFVSTCwgY2FuJ3QgZml4IGl0IHVwISFgKTtcclxuICAgICAgZmluaXNoKC0yKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBmaWxlUGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudCh1cmkucGF0aG5hbWUpO1xyXG5cclxuICAgIC8vIE5COiBwYXRobmFtZSBoYXMgYSBsZWFkaW5nICcvJyBvbiBXaW4zMiBmb3Igc29tZSByZWFzb25cclxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XHJcbiAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGguc2xpY2UoMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTkI6IFNwZWNpYWwtY2FzZSBmaWxlcyBjb21pbmcgZnJvbSBhdG9tLmFzYXIgb3Igbm9kZV9tb2R1bGVzXHJcbiAgICBpZiAoZmlsZVBhdGgubWF0Y2goL1tcXC9cXFxcXShhdG9tfGVsZWN0cm9uKS5hc2FyLykgfHwgZmlsZVBhdGgubWF0Y2goL1tcXC9cXFxcXShub2RlX21vZHVsZXN8Ym93ZXJfY29tcG9uZW50cykvKSkge1xyXG4gICAgICAvLyBOQnMgb24gTkJzOiBJZiB3ZSdyZSBsb2FkaW5nIGFuIEhUTUwgZmlsZSBmcm9tIG5vZGVfbW9kdWxlcywgd2Ugc3RpbGwgaGF2ZVxyXG4gICAgICAvLyB0byBkbyB0aGUgSFRNTCBkb2N1bWVudCByaWdnaW5nXHJcbiAgICAgIGlmIChmaWxlUGF0aC5tYXRjaCgvXFwuaHRtbD8kL2kpKSB7XHJcbiAgICAgICAgbGV0IHJpZ2dlZENvbnRlbnRzID0gbnVsbDtcclxuICAgICAgICBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnLCAoZXJyLCBjb250ZW50cykgPT4ge1xyXG4gICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyLmVycm5vID09PSAzNCkge1xyXG4gICAgICAgICAgICAgIGZpbmlzaCgtNik7IC8vIG5ldDo6RVJSX0ZJTEVfTk9UX0ZPVU5EXHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGZpbmlzaCgtMik7IC8vIG5ldDo6RkFJTEVEXHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmlnZ2VkQ29udGVudHMgPSByaWdIdG1sRG9jdW1lbnRUb0luaXRpYWxpemVFbGVjdHJvbkNvbXBpbGUoY29udGVudHMpO1xyXG4gICAgICAgICAgZmluaXNoKHsgZGF0YTogbmV3IEJ1ZmZlcihyaWdnZWRDb250ZW50cyksIG1pbWVUeXBlOiAndGV4dC9odG1sJyB9KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXF1ZXN0RmlsZUpvYihmaWxlUGF0aCwgZmluaXNoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBjb21waWxlckhvc3QuY29tcGlsZShmaWxlUGF0aCk7XHJcblxyXG4gICAgICBpZiAocmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9odG1sJykge1xyXG4gICAgICAgIHJlc3VsdC5jb2RlID0gcmlnSHRtbERvY3VtZW50VG9Jbml0aWFsaXplRWxlY3Ryb25Db21waWxlKHJlc3VsdC5jb2RlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlc3VsdC5iaW5hcnlEYXRhIHx8IHJlc3VsdC5jb2RlIGluc3RhbmNlb2YgQnVmZmVyKSB7XHJcbiAgICAgICAgZmluaXNoKHsgZGF0YTogcmVzdWx0LmJpbmFyeURhdGEgfHwgcmVzdWx0LmNvZGUsIG1pbWVUeXBlOiByZXN1bHQubWltZVR5cGUgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZpbmlzaCh7IGRhdGE6IG5ldyBCdWZmZXIocmVzdWx0LmNvZGUpLCBtaW1lVHlwZTogcmVzdWx0Lm1pbWVUeXBlIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBsZXQgZXJyID0gYEZhaWxlZCB0byBjb21waWxlICR7ZmlsZVBhdGh9OiAke2UubWVzc2FnZX1cXG4ke2Uuc3RhY2t9YDtcclxuICAgICAgZChlcnIpO1xyXG5cclxuICAgICAgaWYgKGUuZXJybm8gPT09IDM0IC8qRU5PRU5UKi8pIHtcclxuICAgICAgICBmaW5pc2goLTYpOyAvLyBuZXQ6OkVSUl9GSUxFX05PVF9GT1VORFxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZmluaXNoKHsgbWltZVR5cGU6ICd0ZXh0L3BsYWluJywgZGF0YTogbmV3IEJ1ZmZlcihlcnIpIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuIl19