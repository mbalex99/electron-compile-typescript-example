<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/index.js | electron-compilers API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/paulcbetts/spawn-rx" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-findActualExecutable">findActualExecutable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-spawn">spawn</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-spawnDetached">spawnDetached</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-spawnDetachedPromise">spawnDetachedPromise</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-spawnPromise">spawnPromise</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import _ from &apos;lodash&apos;;
import path from &apos;path&apos;;
import net from &apos;net&apos;;
import { Observable, Disposable, AsyncSubject } from &apos;rx&apos;;
import sfs from &apos;fs&apos;;

const spawnOg = require(&apos;child_process&apos;).spawn;
const isWindows = process.platform === &apos;win32&apos;;

const d = require(&apos;debug&apos;)(&apos;surf:promise-array&apos;);

/**
 * stat a file but don&apos;t throw if it doesn&apos;t exist
 *
 * @param  {string} file The path to a file
 * @return {Stats}       The stats structure
 *
 * @private
 */
function statSyncNoException(file) {
  try {
    return sfs.statSync(file);
  } catch (e) {
    return null;
  }
}

/**
 * Search PATH to see if a file exists in any of the path folders.
 *
 * @param  {string} exe The file to search for
 * @return {string}     A fully qualified path, or the original path if nothing
 *                      is found
 *
 * @private
 */
function runDownPath(exe) {
  // NB: Windows won&apos;t search PATH looking for executables in spawn like
  // Posix does

  // Files with any directory path don&apos;t get this applied
  if (exe.match(/[\\\/]/)) {
    d(&apos;Path has slash in directory, bailing&apos;);
    return exe;
  }

  let target = path.join(&apos;.&apos;, exe);
  if (statSyncNoException(target)) {
    d(`Found executable in currect directory: ${target}`);
    return target;
  }

  let haystack = process.env.PATH.split(isWindows ? &apos;;&apos; : &apos;:&apos;);
  for (let p of haystack) {
    let needle = path.join(p, exe);
    if (statSyncNoException(needle)) return needle;
  }

  d(&apos;Failed to find executable anywhere in path&apos;);
  return exe;
}

/**
 * Finds the actual executable and parameters to run on Windows. This method 
 * mimics the POSIX behavior of being able to run scripts as executables by 
 * replacing the passed-in executable with the script runner, for PowerShell, 
 * CMD, and node scripts.
 *
 * This method also does the work of running down PATH, which spawn on Windows
 * also doesn&apos;t do, unlike on POSIX.
 * 
 * @param  {string} exe           The executable to run
 * @param  {Array&lt;string&gt;} args   The arguments to run
 *
 * @return {Object}               The cmd and args to run
 * @property {string} cmd         The command to pass to spawn
 * @property {Array&lt;string&gt;} args The arguments to pass to spawn
 */
export function findActualExecutable(exe, args) {
  // POSIX can just execute scripts directly, no need for silly goosery
  if (process.platform !== &apos;win32&apos;) return { cmd: exe, args: args };
  
  if (!sfs.existsSync(exe)) {
    // NB: When you write something like `surf-client ... -- surf-build` on Windows,
    // a shell would normally convert that to surf-build.cmd, but since it&apos;s passed
    // in as an argument, it doesn&apos;t happen
    const possibleExts = [&apos;.exe&apos;, &apos;.bat&apos;, &apos;.cmd&apos;, &apos;.ps1&apos;];
    for (let ext of possibleExts) {
      let possibleFullPath = runDownPath(`${exe}${ext}`);

      if (sfs.existsSync(possibleFullPath)) {
        return findActualExecutable(possibleFullPath, args);
      }
    }
  }
  
  if (exe.match(/\.ps1$/i)) {
    let cmd = path.join(process.env.SYSTEMROOT, &apos;System32&apos;, &apos;WindowsPowerShell&apos;, &apos;v1.0&apos;, &apos;PowerShell.exe&apos;);
    let psargs = [&apos;-ExecutionPolicy&apos;, &apos;Unrestricted&apos;, &apos;-NoLogo&apos;, &apos;-NonInteractive&apos;, &apos;-File&apos;, exe];

    return { cmd: cmd, args: psargs.concat(args) };
  }

  if (exe.match(/\.(bat|cmd)$/i)) {
    let cmd = path.join(process.env.SYSTEMROOT, &apos;System32&apos;, &apos;cmd.exe&apos;);
    let cmdArgs = [&apos;/C&apos;, exe];

    return { cmd: cmd, args: cmdArgs.concat(args) };
  }

  if (exe.match(/\.(js)$/i)) {
    let cmd = process.execPath;
    let nodeArgs = [exe];

    return { cmd: cmd, args: nodeArgs.concat(args) };
  }

  // Dunno lol
  return { cmd: exe, args: args };
}

/**
 * Spawns a process but detached from the current process. The process is put 
 * into its own Process Group that can be killed by unsubscribing from the 
 * return Observable.
 * 
 * @param  {string} exe               The executable to run
 * @param  {Array&lt;string&gt;} params     The parameters to pass to the child
 * @param  {Object} opts              Options to pass to spawn.
 *
 * @return {Observable&lt;string&gt;}       Returns an Observable that when subscribed
 *                                    to, will create a detached process. The
 *                                    process output will be streamed to this
 *                                    Observable, and if unsubscribed from, the
 *                                    process will be terminated early. If the
 *                                    process terminates with a non-zero value,
 *                                    the Observable will terminate with onError.
 */
export function spawnDetached(exe, params, opts=null) {
  if (!isWindows) return spawn(exe, params, _.assign({}, opts || {}, {detached: true }));
  const newParams = [exe].concat(params);

  let target = path.join(__dirname, &apos;..&apos;, &apos;vendor&apos;, &apos;jobber&apos;, &apos;jobber.exe&apos;);
  let options = _.assign({}, opts || {}, { detached: true, jobber: true });

  d(`spawnDetached: ${target}, ${newParams}`);
  return spawn(target, newParams, options);
}


/**
 * Spawns a process attached as a child of the current process. 
 * 
 * @param  {string} exe               The executable to run
 * @param  {Array&lt;string&gt;} params     The parameters to pass to the child
 * @param  {Object} opts              Options to pass to spawn.
 *
 * @return {Observable&lt;string&gt;}       Returns an Observable that when subscribed
 *                                    to, will create a child process. The
 *                                    process output will be streamed to this
 *                                    Observable, and if unsubscribed from, the
 *                                    process will be terminated early. If the
 *                                    process terminates with a non-zero value,
 *                                    the Observable will terminate with onError.
 */
export function spawn(exe, params=[], opts=null) {
  let spawnObs = Observable.create((subj) =&gt; {
    let proc = null;

    let { cmd, args } = findActualExecutable(exe, params);
    if (!opts) {
      d(`spawning process: ${cmd} ${args.join()}`);
      proc = spawnOg(cmd, args);
    } else {
      d(`spawning process: ${cmd} ${args.join()}, ${JSON.stringify(opts)}`);
      proc = spawnOg(cmd, args, _.omit(opts, &apos;jobber&apos;));
    }
  
    let bufHandler = (b) =&gt; {
      if (b.length &lt; 1) return;
      let chunk = &quot;&lt;&lt; String sent back was too long &gt;&gt;&quot;;
      try {
        chunk = b.toString();
      } catch (e) {
        chunk = `&lt;&lt; Lost chunk of process output for ${exe} - length was ${b.length}&gt;&gt;`;
      }

      subj.onNext(chunk);
    };
    
    let stderrCompleted = null;
    let stdoutCompleted = null;
    let noClose = false;
    
    if (proc.stdout) {
      stdoutCompleted = new AsyncSubject();
      proc.stdout.on(&apos;data&apos;, bufHandler);
      proc.stdout.on(&apos;close&apos;, () =&gt; { stdoutCompleted.onNext(true); stdoutCompleted.onCompleted(); });
    } else {
      stdoutCompleted = Observable.just(true);
    }
    
    if (proc.stderr) {
      stderrCompleted = new AsyncSubject();
      proc.stderr.on(&apos;data&apos;, bufHandler);
      proc.stderr.on(&apos;close&apos;, () =&gt; { stderrCompleted.onNext(true); stderrCompleted.onCompleted(); });
    } else {
      stderrCompleted = Observable.just(true);
    }
    
    proc.stderr.on(&apos;data&apos;, bufHandler);
    proc.on(&apos;error&apos;, (e) =&gt; {
      noClose = true;
      subj.onError(e);
    });

    proc.on(&apos;close&apos;, (code) =&gt; {
      noClose = true;
      let pipesClosed = Observable.merge(stdoutCompleted, stderrCompleted)
        .reduce((acc) =&gt; acc, true);
      
      if (code === 0) {
        pipesClosed.subscribe(() =&gt; subj.onCompleted());
      } else {
        pipesClosed.subscribe(() =&gt; subj.onError(new Error(`Failed with exit code: ${code}`)));
      }
    });

    return Disposable.create(() =&gt; {
      if (noClose) return;

      d(`Killing process: ${cmd} ${args.join()}`);
      if (!opts.jobber) {
        proc.kill();
        return;
      }

      // NB: Connecting to Jobber&apos;s named pipe will kill it
      net.connect(`\\\\.\\pipe\\jobber-${proc.pid}`);
      setTimeout(() =&gt; proc.kill(), 5*1000);
    });
  });

  return spawnObs.publish().refCount();
}

/**
 * Spawns a process but detached from the current process. The process is put 
 * into its own Process Group.
 * 
 * @param  {string} exe               The executable to run
 * @param  {Array&lt;string&gt;} params     The parameters to pass to the child
 * @param  {Object} opts              Options to pass to spawn.
 *
 * @return {Promise&lt;string&gt;}       Returns an Promise that represents a detached 
 *                                 process. The value returned is the process 
 *                                 output. If the process terminates with a 
 *                                 non-zero value, the Promise will resolve with 
 *                                 an Error.
 */
export function spawnDetachedPromise(exe, params, opts=null) {
  return spawnDetached(exe, params, opts).toPromise();
}


/**
 * Spawns a process as a child process.
 * 
 * @param  {string} exe               The executable to run
 * @param  {Array&lt;string&gt;} params     The parameters to pass to the child
 * @param  {Object} opts              Options to pass to spawn.
 *
 * @return {Promise&lt;string&gt;}       Returns an Promise that represents a child
 *                                 process. The value returned is the process 
 *                                 output. If the process terminates with a 
 *                                 non-zero value, the Promise will resolve with 
 *                                 an Error.
 */
export function spawnPromise(exe, params, opts=null) {
  return spawn(exe, params, opts).toPromise();
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
