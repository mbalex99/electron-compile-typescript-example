'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _mimeTypes = require('@paulcbetts/mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _promise = require('./promise');

var _forAllFiles = require('./for-all-files');

var _compileCache = require('./compile-cache');

var _compileCache2 = _interopRequireDefault(_compileCache);

var _fileChangeCache = require('./file-change-cache');

var _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);

var _readOnlyCompiler = require('./read-only-compiler');

var _readOnlyCompiler2 = _interopRequireDefault(_readOnlyCompiler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var d = require('debug')('electron-compile:compiler-host');

// This isn't even my
var finalForms = {
  'text/javascript': true,
  'application/javascript': true,
  'text/html': true,
  'text/css': true,
  'image/svg+xml': true,
  'application/json': true
};

/**
 * This class is the top-level class that encapsulates all of the logic of 
 * compiling and caching application code. If you're looking for a "Main class",
 * this is it.
 * 
 * This class can be created directly but it is usually created via the methods
 * in config-parser, which will among other things, set up the compiler options
 * given a project root.
 * 
 * CompilerHost is also the top-level class that knows how to serialize all of the
 * information necessary to recreate itself, either as a development host (i.e.
 * will allow cache misses and actual compilation), or as a read-only version of
 * itself for production.
 */

var CompilerHost = function () {
  /**  
   * Creates an instance of CompilerHost. You probably want to use the methods
   * in config-parser for development, or {@link createReadonlyFromConfiguration}
   * for production instead.
   *    
   * @param  {string} rootCacheDir  The root directory to use for the cache
   * 
   * @param  {Object} compilers  an Object whose keys are input MIME types and
   *                             whose values are instances of CompilerBase. Create
   *                             this via the {@link createCompilers} method in
   *                             config-parser.
   * 
   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is 
   *                                             optionally pre-loaded.
   * 
   * @param  {boolean} readOnlyMode  If True, cache misses will fail and 
   *                                 compilation will not be attempted.
   * 
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present.
   */

  function CompilerHost(rootCacheDir, compilers, fileChangeCache, readOnlyMode) {
    var fallbackCompiler = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];
    (0, _classCallCheck3.default)(this, CompilerHost);

    var compilersByMimeType = _lodash2.default.assign({}, compilers);
    _lodash2.default.assign(this, { rootCacheDir: rootCacheDir, compilersByMimeType: compilersByMimeType, fileChangeCache: fileChangeCache, readOnlyMode: readOnlyMode, fallbackCompiler: fallbackCompiler });
    this.appRoot = this.fileChangeCache.appRoot;

    this.cachesForCompilers = _lodash2.default.reduce((0, _keys2.default)(compilersByMimeType), function (acc, x) {
      var compiler = compilersByMimeType[x];
      if (acc.has(compiler)) return acc;

      acc.set(compiler, _compileCache2.default.createFromCompiler(rootCacheDir, compiler, fileChangeCache, readOnlyMode));
      return acc;
    }, new _map2.default());
  }

  /**    
   * Creates a production-mode CompilerHost from the previously saved 
   * configuration
   *    
   * @param  {string} rootCacheDir  The root directory to use for the cache. This
   *                                cache must have cache information saved via
   *                                {@link saveConfiguration}
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present. 
   *
   * @return {Promise<CompilerHost>}  A read-only CompilerHost
   */


  (0, _createClass3.default)(CompilerHost, [{
    key: 'saveConfiguration',


    /**  
     * Saves the current compiler configuration to a file that 
     * {@link createReadonlyFromConfiguration} can use to recreate the current 
     * compiler environment
     *    
     * @return {Promise}  Completion
     */
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
        var _this = this;

        var serializedCompilerOpts, info, target, buf;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                serializedCompilerOpts = _lodash2.default.reduce((0, _keys2.default)(this.compilersByMimeType), function (acc, x) {
                  var compiler = _this.compilersByMimeType[x];
                  var Klass = (0, _getPrototypeOf2.default)(compiler).constructor;

                  var val = {
                    name: Klass.name,
                    inputMimeTypes: Klass.getInputMimeTypes(),
                    compilerOptions: compiler.compilerOptions,
                    compilerVersion: compiler.getCompilerVersion()
                  };

                  acc[x] = val;
                  return acc;
                }, {});
                info = {
                  fileChangeCache: this.fileChangeCache.getSavedData(),
                  compilers: serializedCompilerOpts
                };
                target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');
                _context.next = 5;
                return _promise.pzlib.gzip(new Buffer((0, _stringify2.default)(info)));

              case 5:
                buf = _context.sent;
                _context.next = 8;
                return _promise.pfs.writeFile(target, buf);

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function saveConfiguration() {
        return ref.apply(this, arguments);
      }

      return saveConfiguration;
    }()

    /**  
     * Compiles a file and returns the compiled result.
     *    
     * @param  {string} filePath  The path to the file to compile
     *
     * @return {Promise<object>}  An Object with the compiled result
     *
     * @property {Object} hashInfo  The hash information returned from getHashForPath
     * @property {string} code  The source code if the file was a text file
     * @property {Buffer} binaryData  The file if it was a binary file
     * @property {string} mimeType  The MIME type saved in the cache.
     * @property {string[]} dependentFiles  The dependent files returned from 
     *                                      compiling the file, if any.
     */

  }, {
    key: 'compile',
    value: function compile(filePath) {
      return this.readOnlyMode ? this.compileReadOnly(filePath) : this.fullCompile(filePath);
    }

    /**  
     * Handles compilation in read-only mode
     *
     * @private
     */

  }, {
    key: 'compileReadOnly',
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(filePath) {
        var type, hashInfo, compiler, _ref, _code, _binaryData, _mimeType, cache, _ref2, code, binaryData, mimeType;

        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // We guarantee that node_modules are always shipped directly
                type = _mimeTypes2.default.lookup(filePath);

                if (!_fileChangeCache2.default.isInNodeModules(filePath)) {
                  _context2.next = 7;
                  break;
                }

                _context2.t0 = type || 'application/javascript';
                _context2.next = 5;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 5:
                _context2.t1 = _context2.sent;
                return _context2.abrupt('return', {
                  mimeType: _context2.t0,
                  code: _context2.t1
                });

              case 7:
                _context2.next = 9;
                return this.fileChangeCache.getHashForPath(filePath);

              case 9:
                hashInfo = _context2.sent;


                // NB: Here, we're basically only using the compiler here to find
                // the appropriate CompileCache
                compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

                if (compiler) {
                  _context2.next = 20;
                  break;
                }

                compiler = this.fallbackCompiler;

                _context2.next = 15;
                return compiler.get(filePath);

              case 15:
                _ref = _context2.sent;
                _code = _ref.code;
                _binaryData = _ref.binaryData;
                _mimeType = _ref.mimeType;
                return _context2.abrupt('return', { code: _code || _binaryData, mimeType: _mimeType });

              case 20:
                cache = this.cachesForCompilers.get(compiler);
                _context2.next = 23;
                return cache.get(filePath);

              case 23:
                _ref2 = _context2.sent;
                code = _ref2.code;
                binaryData = _ref2.binaryData;
                mimeType = _ref2.mimeType;


                code = code || binaryData;

                if (!(!code || !mimeType)) {
                  _context2.next = 30;
                  break;
                }

                throw new Error('Asked to compile ' + filePath + ' in production, is this file not precompiled?');

              case 30:
                return _context2.abrupt('return', { code: code, mimeType: mimeType });

              case 31:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function compileReadOnly(_x2) {
        return ref.apply(this, arguments);
      }

      return compileReadOnly;
    }()

    /**  
     * Handles compilation in read-write mode
     *
     * @private
     */

  }, {
    key: 'fullCompile',
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(filePath) {
        var _this2 = this;

        var hashInfo, type, code, compiler, cache;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                d('Compiling ' + filePath);

                _context3.next = 3;
                return this.fileChangeCache.getHashForPath(filePath);

              case 3:
                hashInfo = _context3.sent;
                type = _mimeTypes2.default.lookup(filePath);

                if (!hashInfo.isInNodeModules) {
                  _context3.next = 13;
                  break;
                }

                _context3.t0 = hashInfo.sourceCode;

                if (_context3.t0) {
                  _context3.next = 11;
                  break;
                }

                _context3.next = 10;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 10:
                _context3.t0 = _context3.sent;

              case 11:
                code = _context3.t0;
                return _context3.abrupt('return', { code: code, mimeType: type });

              case 13:
                compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];


                if (!compiler) {
                  d('Falling back to passthrough compiler for ' + filePath);
                  compiler = this.fallbackCompiler;
                }

                if (compiler) {
                  _context3.next = 17;
                  break;
                }

                throw new Error('Couldn\'t find a compiler for ' + filePath);

              case 17:
                cache = this.cachesForCompilers.get(compiler);
                _context3.next = 20;
                return cache.getOrFetch(filePath, function (filePath, hashInfo) {
                  return _this2.compileUncached(filePath, hashInfo, compiler);
                });

              case 20:
                return _context3.abrupt('return', _context3.sent);

              case 21:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function fullCompile(_x3) {
        return ref.apply(this, arguments);
      }

      return fullCompile;
    }()

    /**  
     * Handles invoking compilers independent of caching
     *
     * @private
     */

  }, {
    key: 'compileUncached',
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(filePath, hashInfo, compiler) {
        var inputMimeType, ctx, code, dependentFiles, result, shouldInlineHtmlify, isPassthrough;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                inputMimeType = _mimeTypes2.default.lookup(filePath);

                if (!hashInfo.isFileBinary) {
                  _context4.next = 11;
                  break;
                }

                _context4.t0 = hashInfo.binaryData;

                if (_context4.t0) {
                  _context4.next = 7;
                  break;
                }

                _context4.next = 6;
                return _promise.pfs.readFile(filePath);

              case 6:
                _context4.t0 = _context4.sent;

              case 7:
                _context4.t1 = _context4.t0;
                _context4.t2 = inputMimeType;
                _context4.t3 = [];
                return _context4.abrupt('return', {
                  binaryData: _context4.t1,
                  mimeType: _context4.t2,
                  dependentFiles: _context4.t3
                });

              case 11:
                ctx = {};
                _context4.t4 = hashInfo.sourceCode;

                if (_context4.t4) {
                  _context4.next = 17;
                  break;
                }

                _context4.next = 16;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 16:
                _context4.t4 = _context4.sent;

              case 17:
                code = _context4.t4;
                _context4.next = 20;
                return compiler.shouldCompileFile(code, ctx);

              case 20:
                if (_context4.sent) {
                  _context4.next = 23;
                  break;
                }

                d('Compiler returned false for shouldCompileFile: ' + filePath);
                return _context4.abrupt('return', { code: code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] });

              case 23:
                _context4.next = 25;
                return compiler.determineDependentFiles(code, filePath, ctx);

              case 25:
                dependentFiles = _context4.sent;


                d('Using compiler options: ' + (0, _stringify2.default)(compiler.compilerOptions));
                _context4.next = 29;
                return compiler.compile(code, filePath, ctx);

              case 29:
                result = _context4.sent;
                shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';
                isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

                if (!(finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough)) {
                  _context4.next = 36;
                  break;
                }

                return _context4.abrupt('return', _lodash2.default.assign(result, { dependentFiles: dependentFiles }));

              case 36:
                d('Recursively compiling result of ' + filePath + ' with non-final MIME type ' + result.mimeType + ', input was ' + inputMimeType);

                hashInfo = _lodash2.default.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
                compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];

                if (compiler) {
                  _context4.next = 42;
                  break;
                }

                d('Recursive compile failed - intermediate result: ' + (0, _stringify2.default)(result));

                throw new Error('Compiling ' + filePath + ' resulted in a MIME type of ' + result.mimeType + ', which we don\'t know how to handle');

              case 42:
                _context4.next = 44;
                return this.compileUncached(filePath + '.' + _mimeTypes2.default.extension(result.mimeType || 'txt'), hashInfo, compiler);

              case 44:
                return _context4.abrupt('return', _context4.sent);

              case 45:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function compileUncached(_x4, _x5, _x6) {
        return ref.apply(this, arguments);
      }

      return compileUncached;
    }()

    /**  
     * Pre-caches an entire directory of files recursively. Usually used for 
     * building custom compiler tooling.
     *    
     * @param  {string} rootDirectory  The top-level directory to compile
     *
     * @param  {Function} shouldCompile (optional)  A Function which allows the 
     *                                  caller to disable compiling certain files.
     *                                  It takes a fully-qualified path to a file,
     *                                  and should return a Boolean.
     *
     * @return {Promise}  Completion.
     */

  }, {
    key: 'compileAll',
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(rootDirectory) {
        var _this3 = this;

        var shouldCompile = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
        var should;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                should = shouldCompile || function () {
                  return true;
                };

                _context5.next = 3;
                return (0, _forAllFiles.forAllFiles)(rootDirectory, function (f) {
                  if (!should(f)) return;

                  d('Compiling ' + f);
                  return _this3.compile(f, _this3.compilersByMimeType);
                });

              case 3:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function compileAll(_x8) {
        return ref.apply(this, arguments);
      }

      return compileAll;
    }()

    /*
     * Sync Methods
     */

  }, {
    key: 'compileSync',
    value: function compileSync(filePath) {
      return this.readOnlyMode ? this.compileReadOnlySync(filePath) : this.fullCompileSync(filePath);
    }
  }, {
    key: 'saveConfigurationSync',
    value: function saveConfigurationSync() {
      var _this4 = this;

      var serializedCompilerOpts = _lodash2.default.reduce((0, _keys2.default)(this.compilersByMimeType), function (acc, x) {
        var compiler = _this4.compilersByMimeType[x];
        var Klass = (0, _getPrototypeOf2.default)(compiler).constructor;

        var val = {
          name: Klass.name,
          inputMimeTypes: Klass.getInputMimeTypes(),
          compilerOptions: compiler.compilerOptions,
          compilerVersion: compiler.getCompilerVersion()
        };

        acc[x] = val;
        return acc;
      }, {});

      var info = {
        fileChangeCache: this.fileChangeCache.getSavedData(),
        compilers: serializedCompilerOpts
      };

      var target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');
      var buf = _zlib2.default.gzipSync(new Buffer((0, _stringify2.default)(info)));
      _fs2.default.writeFileSync(target, buf);
    }
  }, {
    key: 'compileReadOnlySync',
    value: function compileReadOnlySync(filePath) {
      // We guarantee that node_modules are always shipped directly
      var type = _mimeTypes2.default.lookup(filePath);
      if (_fileChangeCache2.default.isInNodeModules(filePath)) {
        return {
          mimeType: type || 'application/javascript',
          code: _fs2.default.readFileSync(filePath, 'utf8')
        };
      }

      var hashInfo = this.fileChangeCache.getHashForPathSync(filePath);

      // We guarantee that node_modules are always shipped directly
      if (hashInfo.isInNodeModules) {
        return {
          mimeType: type,
          code: hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8')
        };
      }

      // NB: Here, we're basically only using the compiler here to find
      // the appropriate CompileCache
      var compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

      if (!compiler) {
        compiler = this.fallbackCompiler;

        var _compiler$getSync = compiler.getSync(filePath);

        var _code2 = _compiler$getSync.code;
        var _binaryData2 = _compiler$getSync.binaryData;
        var _mimeType2 = _compiler$getSync.mimeType;

        return { code: _code2 || _binaryData2, mimeType: _mimeType2 };
      }

      var cache = this.cachesForCompilers.get(compiler);

      var _cache$getSync = cache.getSync(filePath);

      var code = _cache$getSync.code;
      var binaryData = _cache$getSync.binaryData;
      var mimeType = _cache$getSync.mimeType;


      code = code || binaryData;
      if (!code || !mimeType) {
        throw new Error('Asked to compile ' + filePath + ' in production, is this file not precompiled?');
      }

      return { code: code, mimeType: mimeType };
    }
  }, {
    key: 'fullCompileSync',
    value: function fullCompileSync(filePath) {
      var _this5 = this;

      d('Compiling ' + filePath);

      var hashInfo = this.fileChangeCache.getHashForPathSync(filePath);
      var type = _mimeTypes2.default.lookup(filePath);

      if (hashInfo.isInNodeModules) {
        var code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');
        return { code: code, mimeType: type };
      }

      var compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

      if (!compiler) {
        d('Falling back to passthrough compiler for ' + filePath);
        compiler = this.fallbackCompiler;
      }

      if (!compiler) {
        throw new Error('Couldn\'t find a compiler for ' + filePath);
      }

      var cache = this.cachesForCompilers.get(compiler);
      return cache.getOrFetchSync(filePath, function (filePath, hashInfo) {
        return _this5.compileUncachedSync(filePath, hashInfo, compiler);
      });
    }
  }, {
    key: 'compileUncachedSync',
    value: function compileUncachedSync(filePath, hashInfo, compiler) {
      var inputMimeType = _mimeTypes2.default.lookup(filePath);

      if (hashInfo.isFileBinary) {
        return {
          binaryData: hashInfo.binaryData || _fs2.default.readFileSync(filePath),
          mimeType: inputMimeType,
          dependentFiles: []
        };
      }

      var ctx = {};
      var code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');

      if (!compiler.shouldCompileFileSync(code, ctx)) {
        d('Compiler returned false for shouldCompileFile: ' + filePath);
        return { code: code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };
      }

      var dependentFiles = compiler.determineDependentFilesSync(code, filePath, ctx);

      var result = compiler.compileSync(code, filePath, ctx);

      var shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';

      var isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

      if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {
        // Got something we can use in-browser, let's return it
        return _lodash2.default.assign(result, { dependentFiles: dependentFiles });
      } else {
        d('Recursively compiling result of ' + filePath + ' with non-final MIME type ' + result.mimeType + ', input was ' + inputMimeType);

        hashInfo = _lodash2.default.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
        compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];

        if (!compiler) {
          d('Recursive compile failed - intermediate result: ' + (0, _stringify2.default)(result));

          throw new Error('Compiling ' + filePath + ' resulted in a MIME type of ' + result.mimeType + ', which we don\'t know how to handle');
        }

        return this.compileUncachedSync(filePath + '.' + _mimeTypes2.default.extension(result.mimeType || 'txt'), hashInfo, compiler);
      }
    }
  }, {
    key: 'compileAllSync',
    value: function compileAllSync(rootDirectory) {
      var _this6 = this;

      var shouldCompile = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      var should = shouldCompile || function () {
        return true;
      };

      (0, _forAllFiles.forAllFilesSync)(rootDirectory, function (f) {
        if (!should(f)) return;
        return _this6.compileSync(f, _this6.compilersByMimeType);
      });
    }

    /*
     * Other stuff
     */

    /**
     * Returns the passthrough compiler 
     *
     * @private
     */

  }, {
    key: 'getPassthroughCompiler',
    value: function getPassthroughCompiler() {
      return this.compilersByMimeType['text/plain'];
    }

    /**
     * Determines whether we should even try to compile the content. Note that in
     * some cases, content will still be in cache even if this returns true, and
     * in other cases (isInNodeModules), we'll know explicitly to not even bother
     * looking in the cache.
     *    
     * @private
     */

  }], [{
    key: 'createReadonlyFromConfiguration',
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(rootCacheDir, appRoot) {
        var fallbackCompiler = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
        var target, buf, info, fileChangeCache, compilers;
        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
                _context6.next = 3;
                return _promise.pfs.readFile(target);

              case 3:
                buf = _context6.sent;
                _context6.t0 = JSON;
                _context6.next = 7;
                return _promise.pzlib.gunzip(buf);

              case 7:
                _context6.t1 = _context6.sent;
                info = _context6.t0.parse.call(_context6.t0, _context6.t1);
                fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);
                compilers = _lodash2.default.reduce((0, _keys2.default)(info.compilers), function (acc, x) {
                  var cur = info.compilers[x];
                  acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

                  return acc;
                }, {});
                return _context6.abrupt('return', new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler));

              case 12:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function createReadonlyFromConfiguration(_x11, _x12) {
        return ref.apply(this, arguments);
      }

      return createReadonlyFromConfiguration;
    }()

    /**    
     * Creates a development-mode CompilerHost from the previously saved 
     * configuration.
     *    
     * @param  {string} rootCacheDir  The root directory to use for the cache. This
     *                                cache must have cache information saved via
     *                                {@link saveConfiguration}
     *
     * @param  {string} appRoot  The top-level directory for your application (i.e.
     *                           the one which has your package.json).
     *
     * @param  {Object} compilersByMimeType  an Object whose keys are input MIME 
     *                                       types and whose values are instances 
     *                                       of CompilerBase. Create this via the 
     *                                       {@link createCompilers} method in 
     *                                       config-parser.
     * 
     * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
     *                                         which doesn't have a matching compiler,
     *                                         this compiler will be used instead. If
     *                                         null, will fail compilation. A good
     *                                         alternate fallback is the compiler for
     *                                         'text/plain', which is guaranteed to be
     *                                         present. 
     *
     * @return {Promise<CompilerHost>}  A read-only CompilerHost
     */

  }, {
    key: 'createFromConfiguration',
    value: function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(rootCacheDir, appRoot, compilersByMimeType) {
        var fallbackCompiler = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
        var target, buf, info, fileChangeCache;
        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
                _context7.next = 3;
                return _promise.pfs.readFile(target);

              case 3:
                buf = _context7.sent;
                _context7.t0 = JSON;
                _context7.next = 7;
                return _promise.pzlib.gunzip(buf);

              case 7:
                _context7.t1 = _context7.sent;
                info = _context7.t0.parse.call(_context7.t0, _context7.t1);
                fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);


                _lodash2.default.each((0, _keys2.default)(info.compilers), function (x) {
                  var cur = info.compilers[x];
                  compilersByMimeType[x].compilerOptions = cur.compilerOptions;
                });

                return _context7.abrupt('return', new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler));

              case 12:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function createFromConfiguration(_x14, _x15, _x16) {
        return ref.apply(this, arguments);
      }

      return createFromConfiguration;
    }()
  }, {
    key: 'createReadonlyFromConfigurationSync',
    value: function createReadonlyFromConfigurationSync(rootCacheDir, appRoot) {
      var fallbackCompiler = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

      var target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      var buf = _fs2.default.readFileSync(target);
      var info = JSON.parse(_zlib2.default.gunzipSync(buf));

      var fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);

      var compilers = _lodash2.default.reduce((0, _keys2.default)(info.compilers), function (acc, x) {
        var cur = info.compilers[x];
        acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

        return acc;
      }, {});

      return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);
    }
  }, {
    key: 'createFromConfigurationSync',
    value: function createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType) {
      var fallbackCompiler = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

      var target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      var buf = _fs2.default.readFileSync(target);
      var info = JSON.parse(_zlib2.default.gunzipSync(buf));

      var fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);

      _lodash2.default.each((0, _keys2.default)(info.compilers), function (x) {
        var cur = info.compilers[x];
        compilersByMimeType[x].compilerOptions = cur.compilerOptions;
      });

      return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);
    }
  }, {
    key: 'shouldPassthrough',
    value: function shouldPassthrough(hashInfo) {
      return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;
    }
  }]);
  return CompilerHost;
}();

exports.default = CompilerHost;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21waWxlci1ob3N0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUVBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTSxJQUFJLFFBQVEsT0FBUixFQUFpQixnQ0FBakIsQ0FBVjs7O0FBR0EsSUFBTSxhQUFhO0FBQ2pCLHFCQUFtQixJQURGO0FBRWpCLDRCQUEwQixJQUZUO0FBR2pCLGVBQWEsSUFISTtBQUlqQixjQUFZLElBSks7QUFLakIsbUJBQWlCLElBTEE7QUFNakIsc0JBQW9CO0FBTkgsQ0FBbkI7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBdUJxQixZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJuQix3QkFBWSxZQUFaLEVBQTBCLFNBQTFCLEVBQXFDLGVBQXJDLEVBQXNELFlBQXRELEVBQTZGO0FBQUEsUUFBekIsZ0JBQXlCLHlEQUFOLElBQU07QUFBQTs7QUFDM0YsUUFBSSxzQkFBc0IsaUJBQUUsTUFBRixDQUFTLEVBQVQsRUFBYSxTQUFiLENBQTFCO0FBQ0EscUJBQUUsTUFBRixDQUFTLElBQVQsRUFBZSxFQUFDLDBCQUFELEVBQWUsd0NBQWYsRUFBb0MsZ0NBQXBDLEVBQXFELDBCQUFyRCxFQUFtRSxrQ0FBbkUsRUFBZjtBQUNBLFNBQUssT0FBTCxHQUFlLEtBQUssZUFBTCxDQUFxQixPQUFwQzs7QUFFQSxTQUFLLGtCQUFMLEdBQTBCLGlCQUFFLE1BQUYsQ0FBUyxvQkFBWSxtQkFBWixDQUFULEVBQTJDLFVBQUMsR0FBRCxFQUFNLENBQU4sRUFBWTtBQUMvRSxVQUFJLFdBQVcsb0JBQW9CLENBQXBCLENBQWY7QUFDQSxVQUFJLElBQUksR0FBSixDQUFRLFFBQVIsQ0FBSixFQUF1QixPQUFPLEdBQVA7O0FBRXZCLFVBQUksR0FBSixDQUNFLFFBREYs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c3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgbWltZVR5cGVzIGZyb20gJ0BwYXVsY2JldHRzL21pbWUtdHlwZXMnO1xyXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgemxpYiBmcm9tICd6bGliJztcclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7cGZzLCBwemxpYn0gZnJvbSAnLi9wcm9taXNlJztcclxuXHJcbmltcG9ydCB7Zm9yQWxsRmlsZXMsIGZvckFsbEZpbGVzU3luY30gZnJvbSAnLi9mb3ItYWxsLWZpbGVzJztcclxuaW1wb3J0IENvbXBpbGVDYWNoZSBmcm9tICcuL2NvbXBpbGUtY2FjaGUnO1xyXG5pbXBvcnQgRmlsZUNoYW5nZWRDYWNoZSBmcm9tICcuL2ZpbGUtY2hhbmdlLWNhY2hlJztcclxuaW1wb3J0IFJlYWRPbmx5Q29tcGlsZXIgZnJvbSAnLi9yZWFkLW9ubHktY29tcGlsZXInO1xyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6Y29tcGlsZXItaG9zdCcpO1xyXG5cclxuLy8gVGhpcyBpc24ndCBldmVuIG15XHJcbmNvbnN0IGZpbmFsRm9ybXMgPSB7XHJcbiAgJ3RleHQvamF2YXNjcmlwdCc6IHRydWUsXHJcbiAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnOiB0cnVlLFxyXG4gICd0ZXh0L2h0bWwnOiB0cnVlLFxyXG4gICd0ZXh0L2Nzcyc6IHRydWUsXHJcbiAgJ2ltYWdlL3N2Zyt4bWwnOiB0cnVlLFxyXG4gICdhcHBsaWNhdGlvbi9qc29uJzogdHJ1ZVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaXMgdGhlIHRvcC1sZXZlbCBjbGFzcyB0aGF0IGVuY2Fwc3VsYXRlcyBhbGwgb2YgdGhlIGxvZ2ljIG9mIFxyXG4gKiBjb21waWxpbmcgYW5kIGNhY2hpbmcgYXBwbGljYXRpb24gY29kZS4gSWYgeW91J3JlIGxvb2tpbmcgZm9yIGEgXCJNYWluIGNsYXNzXCIsXHJcbiAqIHRoaXMgaXMgaXQuXHJcbiAqIFxyXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSBjcmVhdGVkIGRpcmVjdGx5IGJ1dCBpdCBpcyB1c3VhbGx5IGNyZWF0ZWQgdmlhIHRoZSBtZXRob2RzXHJcbiAqIGluIGNvbmZpZy1wYXJzZXIsIHdoaWNoIHdpbGwgYW1vbmcgb3RoZXIgdGhpbmdzLCBzZXQgdXAgdGhlIGNvbXBpbGVyIG9wdGlvbnNcclxuICogZ2l2ZW4gYSBwcm9qZWN0IHJvb3QuXHJcbiAqIFxyXG4gKiBDb21waWxlckhvc3QgaXMgYWxzbyB0aGUgdG9wLWxldmVsIGNsYXNzIHRoYXQga25vd3MgaG93IHRvIHNlcmlhbGl6ZSBhbGwgb2YgdGhlXHJcbiAqIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byByZWNyZWF0ZSBpdHNlbGYsIGVpdGhlciBhcyBhIGRldmVsb3BtZW50IGhvc3QgKGkuZS5cclxuICogd2lsbCBhbGxvdyBjYWNoZSBtaXNzZXMgYW5kIGFjdHVhbCBjb21waWxhdGlvbiksIG9yIGFzIGEgcmVhZC1vbmx5IHZlcnNpb24gb2ZcclxuICogaXRzZWxmIGZvciBwcm9kdWN0aW9uLlxyXG4gKi8gXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBpbGVySG9zdCB7XHJcbiAgLyoqICBcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENvbXBpbGVySG9zdC4gWW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIHRoZSBtZXRob2RzXHJcbiAgICogaW4gY29uZmlnLXBhcnNlciBmb3IgZGV2ZWxvcG1lbnQsIG9yIHtAbGluayBjcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9ufVxyXG4gICAqIGZvciBwcm9kdWN0aW9uIGluc3RlYWQuXHJcbiAgICogICAgXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgIFRoZSByb290IGRpcmVjdG9yeSB0byB1c2UgZm9yIHRoZSBjYWNoZVxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29tcGlsZXJzICBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgaW5wdXQgTUlNRSB0eXBlcyBhbmRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hvc2UgdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgQ29tcGlsZXJCYXNlLiBDcmVhdGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB2aWEgdGhlIHtAbGluayBjcmVhdGVDb21waWxlcnN9IG1ldGhvZCBpblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWctcGFyc2VyLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSAge0ZpbGVDaGFuZ2VkQ2FjaGV9IGZpbGVDaGFuZ2VDYWNoZSAgQSBmaWxlLWNoYW5nZSBjYWNoZSB0aGF0IGlzIFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxseSBwcmUtbG9hZGVkLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IHJlYWRPbmx5TW9kZSAgSWYgVHJ1ZSwgY2FjaGUgbWlzc2VzIHdpbGwgZmFpbCBhbmQgXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21waWxhdGlvbiB3aWxsIG5vdCBiZSBhdHRlbXB0ZWQuXHJcbiAgICogXHJcbiAgICogQHBhcmFtICB7Q29tcGlsZXJCYXNlfSBmYWxsYmFja0NvbXBpbGVyIChvcHRpb25hbCkgIFdoZW4gYSBmaWxlIGlzIGNvbXBpbGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGNvbXBpbGVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCB3aWxsIGZhaWwgY29tcGlsYXRpb24uIEEgZ29vZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC9wbGFpbicsIHdoaWNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudC5cclxuICAgKi8gICBcclxuICBjb25zdHJ1Y3Rvcihyb290Q2FjaGVEaXIsIGNvbXBpbGVycywgZmlsZUNoYW5nZUNhY2hlLCByZWFkT25seU1vZGUsIGZhbGxiYWNrQ29tcGlsZXIgPSBudWxsKSB7XHJcbiAgICBsZXQgY29tcGlsZXJzQnlNaW1lVHlwZSA9IF8uYXNzaWduKHt9LCBjb21waWxlcnMpO1xyXG4gICAgXy5hc3NpZ24odGhpcywge3Jvb3RDYWNoZURpciwgY29tcGlsZXJzQnlNaW1lVHlwZSwgZmlsZUNoYW5nZUNhY2hlLCByZWFkT25seU1vZGUsIGZhbGxiYWNrQ29tcGlsZXJ9KTtcclxuICAgIHRoaXMuYXBwUm9vdCA9IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmFwcFJvb3Q7XHJcbiAgICBcclxuICAgIHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzID0gXy5yZWR1Y2UoT2JqZWN0LmtleXMoY29tcGlsZXJzQnlNaW1lVHlwZSksIChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGNvbXBpbGVyID0gY29tcGlsZXJzQnlNaW1lVHlwZVt4XTtcclxuICAgICAgaWYgKGFjYy5oYXMoY29tcGlsZXIpKSByZXR1cm4gYWNjO1xyXG5cclxuICAgICAgYWNjLnNldChcclxuICAgICAgICBjb21waWxlciwgXHJcbiAgICAgICAgQ29tcGlsZUNhY2hlLmNyZWF0ZUZyb21Db21waWxlcihyb290Q2FjaGVEaXIsIGNvbXBpbGVyLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSkpO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwgbmV3IE1hcCgpKTtcclxuICB9XHJcbiAgICBcclxuICAvKiogICAgXHJcbiAgICogQ3JlYXRlcyBhIHByb2R1Y3Rpb24tbW9kZSBDb21waWxlckhvc3QgZnJvbSB0aGUgcHJldmlvdXNseSBzYXZlZCBcclxuICAgKiBjb25maWd1cmF0aW9uXHJcbiAgICogICAgXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgIFRoZSByb290IGRpcmVjdG9yeSB0byB1c2UgZm9yIHRoZSBjYWNoZS4gVGhpc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSBtdXN0IGhhdmUgY2FjaGUgaW5mb3JtYXRpb24gc2F2ZWQgdmlhXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBzYXZlQ29uZmlndXJhdGlvbn1cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvbmUgd2hpY2ggaGFzIHlvdXIgcGFja2FnZS5qc29uKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0NvbXBpbGVyQmFzZX0gZmFsbGJhY2tDb21waWxlciAob3B0aW9uYWwpICBXaGVuIGEgZmlsZSBpcyBjb21waWxlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBkb2Vzbid0IGhhdmUgYSBtYXRjaGluZyBjb21waWxlcixcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBjb21waWxlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWZcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgd2lsbCBmYWlsIGNvbXBpbGF0aW9uLiBBIGdvb2RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRlIGZhbGxiYWNrIGlzIHRoZSBjb21waWxlciBmb3JcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nLCB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnQuIFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZTxDb21waWxlckhvc3Q+fSAgQSByZWFkLW9ubHkgQ29tcGlsZXJIb3N0XHJcbiAgICovICAgXHJcbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb24ocm9vdENhY2hlRGlyLCBhcHBSb290LCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcclxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XHJcbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKHRhcmdldCk7XHJcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcHpsaWIuZ3VuemlwKGJ1ZikpO1xyXG4gICAgXHJcbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIHRydWUpO1xyXG5cclxuICAgIGxldCBjb21waWxlcnMgPSBfLnJlZHVjZShPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycyksIChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xyXG4gICAgICBhY2NbeF0gPSBuZXcgUmVhZE9ubHlDb21waWxlcihjdXIubmFtZSwgY3VyLmNvbXBpbGVyVmVyc2lvbiwgY3VyLmNvbXBpbGVyT3B0aW9ucywgY3VyLmlucHV0TWltZVR5cGVzKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcbiAgICBcclxuICAgIHJldHVybiBuZXcgQ29tcGlsZXJIb3N0KHJvb3RDYWNoZURpciwgY29tcGlsZXJzLCBmaWxlQ2hhbmdlQ2FjaGUsIHRydWUsIGZhbGxiYWNrQ29tcGlsZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqICAgIFxyXG4gICAqIENyZWF0ZXMgYSBkZXZlbG9wbWVudC1tb2RlIENvbXBpbGVySG9zdCBmcm9tIHRoZSBwcmV2aW91c2x5IHNhdmVkIFxyXG4gICAqIGNvbmZpZ3VyYXRpb24uXHJcbiAgICogICAgXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgIFRoZSByb290IGRpcmVjdG9yeSB0byB1c2UgZm9yIHRoZSBjYWNoZS4gVGhpc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSBtdXN0IGhhdmUgY2FjaGUgaW5mb3JtYXRpb24gc2F2ZWQgdmlhXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBzYXZlQ29uZmlndXJhdGlvbn1cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvbmUgd2hpY2ggaGFzIHlvdXIgcGFja2FnZS5qc29uKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29tcGlsZXJzQnlNaW1lVHlwZSAgYW4gT2JqZWN0IHdob3NlIGtleXMgYXJlIGlucHV0IE1JTUUgXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlcyBhbmQgd2hvc2UgdmFsdWVzIGFyZSBpbnN0YW5jZXMgXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBDb21waWxlckJhc2UuIENyZWF0ZSB0aGlzIHZpYSB0aGUgXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgY3JlYXRlQ29tcGlsZXJzfSBtZXRob2QgaW4gXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWctcGFyc2VyLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSAge0NvbXBpbGVyQmFzZX0gZmFsbGJhY2tDb21waWxlciAob3B0aW9uYWwpICBXaGVuIGEgZmlsZSBpcyBjb21waWxlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBkb2Vzbid0IGhhdmUgYSBtYXRjaGluZyBjb21waWxlcixcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBjb21waWxlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWZcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgd2lsbCBmYWlsIGNvbXBpbGF0aW9uLiBBIGdvb2RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRlIGZhbGxiYWNrIGlzIHRoZSBjb21waWxlciBmb3JcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nLCB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnQuIFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZTxDb21waWxlckhvc3Q+fSAgQSByZWFkLW9ubHkgQ29tcGlsZXJIb3N0XHJcbiAgICovICAgXHJcbiAgc3RhdGljIGFzeW5jIGNyZWF0ZUZyb21Db25maWd1cmF0aW9uKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgY29tcGlsZXJzQnlNaW1lVHlwZSwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZSh0YXJnZXQpO1xyXG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGF3YWl0IHB6bGliLmd1bnppcChidWYpKTtcclxuICAgIFxyXG4gICAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGluZm8uZmlsZUNoYW5nZUNhY2hlLCBhcHBSb290LCBmYWxzZSk7XHJcbiAgICBcclxuICAgIF8uZWFjaChPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycyksICh4KSA9PiB7XHJcbiAgICAgIGxldCBjdXIgPSBpbmZvLmNvbXBpbGVyc1t4XTtcclxuICAgICAgY29tcGlsZXJzQnlNaW1lVHlwZVt4XS5jb21waWxlck9wdGlvbnMgPSBjdXIuY29tcGlsZXJPcHRpb25zO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBuZXcgQ29tcGlsZXJIb3N0KHJvb3RDYWNoZURpciwgY29tcGlsZXJzQnlNaW1lVHlwZSwgZmlsZUNoYW5nZUNhY2hlLCBmYWxzZSwgZmFsbGJhY2tDb21waWxlcik7XHJcbiAgfVxyXG4gIFxyXG4gIFxyXG4gIC8qKiAgXHJcbiAgICogU2F2ZXMgdGhlIGN1cnJlbnQgY29tcGlsZXIgY29uZmlndXJhdGlvbiB0byBhIGZpbGUgdGhhdCBcclxuICAgKiB7QGxpbmsgY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvbn0gY2FuIHVzZSB0byByZWNyZWF0ZSB0aGUgY3VycmVudCBcclxuICAgKiBjb21waWxlciBlbnZpcm9ubWVudFxyXG4gICAqICAgIFxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICBDb21wbGV0aW9uXHJcbiAgICovICAgXHJcbiAgYXN5bmMgc2F2ZUNvbmZpZ3VyYXRpb24oKSB7XHJcbiAgICBsZXQgc2VyaWFsaXplZENvbXBpbGVyT3B0cyA9IF8ucmVkdWNlKE9iamVjdC5rZXlzKHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZSksIChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3hdO1xyXG4gICAgICBsZXQgS2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcGlsZXIpLmNvbnN0cnVjdG9yO1xyXG4gICAgICBcclxuICAgICAgbGV0IHZhbCA9IHtcclxuICAgICAgICBuYW1lOiBLbGFzcy5uYW1lLFxyXG4gICAgICAgIGlucHV0TWltZVR5cGVzOiBLbGFzcy5nZXRJbnB1dE1pbWVUeXBlcygpLFxyXG4gICAgICAgIGNvbXBpbGVyT3B0aW9uczogY29tcGlsZXIuY29tcGlsZXJPcHRpb25zLFxyXG4gICAgICAgIGNvbXBpbGVyVmVyc2lvbjogY29tcGlsZXIuZ2V0Q29tcGlsZXJWZXJzaW9uKClcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIGFjY1t4XSA9IHZhbDtcclxuICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9KTtcclxuICAgIFxyXG4gICAgbGV0IGluZm8gPSB7XHJcbiAgICAgIGZpbGVDaGFuZ2VDYWNoZTogdGhpcy5maWxlQ2hhbmdlQ2FjaGUuZ2V0U2F2ZWREYXRhKCksXHJcbiAgICAgIGNvbXBpbGVyczogc2VyaWFsaXplZENvbXBpbGVyT3B0c1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLnJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHB6bGliLmd6aXAobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShpbmZvKSkpO1xyXG4gICAgYXdhaXQgcGZzLndyaXRlRmlsZSh0YXJnZXQsIGJ1Zik7XHJcbiAgfVxyXG4gIFxyXG4gIC8qKiAgXHJcbiAgICogQ29tcGlsZXMgYSBmaWxlIGFuZCByZXR1cm5zIHRoZSBjb21waWxlZCByZXN1bHQuXHJcbiAgICogICAgXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBmaWxlUGF0aCAgVGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gY29tcGlsZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UHJvbWlzZTxvYmplY3Q+fSAgQW4gT2JqZWN0IHdpdGggdGhlIGNvbXBpbGVkIHJlc3VsdFxyXG4gICAqXHJcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGhhc2hJbmZvICBUaGUgaGFzaCBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGdldEhhc2hGb3JQYXRoXHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgIFRoZSBzb3VyY2UgY29kZSBpZiB0aGUgZmlsZSB3YXMgYSB0ZXh0IGZpbGVcclxuICAgKiBAcHJvcGVydHkge0J1ZmZlcn0gYmluYXJ5RGF0YSAgVGhlIGZpbGUgaWYgaXQgd2FzIGEgYmluYXJ5IGZpbGVcclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbWltZVR5cGUgIFRoZSBNSU1FIHR5cGUgc2F2ZWQgaW4gdGhlIGNhY2hlLlxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGRlcGVuZGVudEZpbGVzICBUaGUgZGVwZW5kZW50IGZpbGVzIHJldHVybmVkIGZyb20gXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGluZyB0aGUgZmlsZSwgaWYgYW55LlxyXG4gICAqLyAgIFxyXG4gIGNvbXBpbGUoZmlsZVBhdGgpIHtcclxuICAgIHJldHVybiAodGhpcy5yZWFkT25seU1vZGUgPyB0aGlzLmNvbXBpbGVSZWFkT25seShmaWxlUGF0aCkgOiB0aGlzLmZ1bGxDb21waWxlKGZpbGVQYXRoKSk7XHJcbiAgfVxyXG4gIFxyXG4gIFxyXG4gIC8qKiAgXHJcbiAgICogSGFuZGxlcyBjb21waWxhdGlvbiBpbiByZWFkLW9ubHkgbW9kZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi8gICBcclxuICBhc3luYyBjb21waWxlUmVhZE9ubHkoZmlsZVBhdGgpIHtcclxuICAgIC8vIFdlIGd1YXJhbnRlZSB0aGF0IG5vZGVfbW9kdWxlcyBhcmUgYWx3YXlzIHNoaXBwZWQgZGlyZWN0bHlcclxuICAgIGxldCB0eXBlID0gbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCk7XHJcbiAgICBpZiAoRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpKSB7XHJcbiAgICAgIHJldHVybiB7IFxyXG4gICAgICAgIG1pbWVUeXBlOiB0eXBlIHx8ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcclxuICAgICAgICBjb2RlOiBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4JykgXHJcbiAgICAgIH07ICAgIFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBsZXQgaGFzaEluZm8gPSBhd2FpdCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aChmaWxlUGF0aCk7XHJcblxyXG4gICAgLy8gTkI6IEhlcmUsIHdlJ3JlIGJhc2ljYWxseSBvbmx5IHVzaW5nIHRoZSBjb21waWxlciBoZXJlIHRvIGZpbmRcclxuICAgIC8vIHRoZSBhcHByb3ByaWF0ZSBDb21waWxlQ2FjaGVcclxuICAgIGxldCBjb21waWxlciA9IENvbXBpbGVySG9zdC5zaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbykgP1xyXG4gICAgICB0aGlzLmdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKSA6XHJcbiAgICAgIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt0eXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcclxuXHJcbiAgICBpZiAoIWNvbXBpbGVyKSB7IFxyXG4gICAgICBjb21waWxlciA9IHRoaXMuZmFsbGJhY2tDb21waWxlcjtcclxuXHJcbiAgICAgIGxldCB7IGNvZGUsIGJpbmFyeURhdGEsIG1pbWVUeXBlIH0gPSBhd2FpdCBjb21waWxlci5nZXQoZmlsZVBhdGgpO1xyXG4gICAgICByZXR1cm4geyBjb2RlOiBjb2RlIHx8IGJpbmFyeURhdGEsIG1pbWVUeXBlIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNhY2hlID0gdGhpcy5jYWNoZXNGb3JDb21waWxlcnMuZ2V0KGNvbXBpbGVyKTtcclxuICAgIGxldCB7Y29kZSwgYmluYXJ5RGF0YSwgbWltZVR5cGV9ID0gYXdhaXQgY2FjaGUuZ2V0KGZpbGVQYXRoKTtcclxuXHJcbiAgICBjb2RlID0gY29kZSB8fCBiaW5hcnlEYXRhO1xyXG4gICAgaWYgKCFjb2RlIHx8ICFtaW1lVHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFza2VkIHRvIGNvbXBpbGUgJHtmaWxlUGF0aH0gaW4gcHJvZHVjdGlvbiwgaXMgdGhpcyBmaWxlIG5vdCBwcmVjb21waWxlZD9gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZSB9O1xyXG4gIH1cclxuXHJcbiAgLyoqICBcclxuICAgKiBIYW5kbGVzIGNvbXBpbGF0aW9uIGluIHJlYWQtd3JpdGUgbW9kZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi8gICAgIFxyXG4gIGFzeW5jIGZ1bGxDb21waWxlKGZpbGVQYXRoKSB7XHJcbiAgICBkKGBDb21waWxpbmcgJHtmaWxlUGF0aH1gKTtcclxuICAgIFxyXG4gICAgbGV0IGhhc2hJbmZvID0gYXdhaXQgdGhpcy5maWxlQ2hhbmdlQ2FjaGUuZ2V0SGFzaEZvclBhdGgoZmlsZVBhdGgpO1xyXG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuICAgIFxyXG4gICAgaWYgKGhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcykge1xyXG4gICAgICBsZXQgY29kZSA9IGhhc2hJbmZvLnNvdXJjZUNvZGUgfHwgYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpO1xyXG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogdHlwZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjb21waWxlciA9IENvbXBpbGVySG9zdC5zaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbykgP1xyXG4gICAgICB0aGlzLmdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKSA6XHJcbiAgICAgIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt0eXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcclxuXHJcbiAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgIGQoYEZhbGxpbmcgYmFjayB0byBwYXNzdGhyb3VnaCBjb21waWxlciBmb3IgJHtmaWxlUGF0aH1gKTtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb21waWxlcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgYSBjb21waWxlciBmb3IgJHtmaWxlUGF0aH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xyXG4gICAgcmV0dXJuIGF3YWl0IGNhY2hlLmdldE9yRmV0Y2goXHJcbiAgICAgIGZpbGVQYXRoLFxyXG4gICAgICAoZmlsZVBhdGgsIGhhc2hJbmZvKSA9PiB0aGlzLmNvbXBpbGVVbmNhY2hlZChmaWxlUGF0aCwgaGFzaEluZm8sIGNvbXBpbGVyKSk7XHJcbiAgfVxyXG5cclxuICAvKiogIFxyXG4gICAqIEhhbmRsZXMgaW52b2tpbmcgY29tcGlsZXJzIGluZGVwZW5kZW50IG9mIGNhY2hpbmdcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgYXN5bmMgY29tcGlsZVVuY2FjaGVkKGZpbGVQYXRoLCBoYXNoSW5mbywgY29tcGlsZXIpIHtcclxuICAgIGxldCBpbnB1dE1pbWVUeXBlID0gbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCk7XHJcbiAgICBcclxuICAgIGlmIChoYXNoSW5mby5pc0ZpbGVCaW5hcnkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBiaW5hcnlEYXRhOiBoYXNoSW5mby5iaW5hcnlEYXRhIHx8IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCksXHJcbiAgICAgICAgbWltZVR5cGU6IGlucHV0TWltZVR5cGUsXHJcbiAgICAgICAgZGVwZW5kZW50RmlsZXM6IFtdXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGxldCBjdHggPSB7fTtcclxuICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XHJcblxyXG4gICAgaWYgKCEoYXdhaXQgY29tcGlsZXIuc2hvdWxkQ29tcGlsZUZpbGUoY29kZSwgY3R4KSkpIHtcclxuICAgICAgZChgQ29tcGlsZXIgcmV0dXJuZWQgZmFsc2UgZm9yIHNob3VsZENvbXBpbGVGaWxlOiAke2ZpbGVQYXRofWApO1xyXG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCksIGRlcGVuZGVudEZpbGVzOiBbXSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkZXBlbmRlbnRGaWxlcyA9IGF3YWl0IGNvbXBpbGVyLmRldGVybWluZURlcGVuZGVudEZpbGVzKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xyXG5cclxuICAgIGQoYFVzaW5nIGNvbXBpbGVyIG9wdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoY29tcGlsZXIuY29tcGlsZXJPcHRpb25zKX1gKTtcclxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjb21waWxlci5jb21waWxlKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xyXG5cclxuICAgIGxldCBzaG91bGRJbmxpbmVIdG1saWZ5ID0gXHJcbiAgICAgIGlucHV0TWltZVR5cGUgIT09ICd0ZXh0L2h0bWwnICYmXHJcbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvaHRtbCc7XHJcbiAgICBcclxuICAgIGxldCBpc1Bhc3N0aHJvdWdoID0gXHJcbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvcGxhaW4nIHx8IFxyXG4gICAgICAhcmVzdWx0Lm1pbWVUeXBlIHx8IFxyXG4gICAgICBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pO1xyXG4gICAgICBcclxuICAgIGlmICgoZmluYWxGb3Jtc1tyZXN1bHQubWltZVR5cGVdICYmICFzaG91bGRJbmxpbmVIdG1saWZ5KSB8fCBpc1Bhc3N0aHJvdWdoKSB7XHJcbiAgICAgIC8vIEdvdCBzb21ldGhpbmcgd2UgY2FuIHVzZSBpbi1icm93c2VyLCBsZXQncyByZXR1cm4gaXRcclxuICAgICAgcmV0dXJuIF8uYXNzaWduKHJlc3VsdCwge2RlcGVuZGVudEZpbGVzfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkKGBSZWN1cnNpdmVseSBjb21waWxpbmcgcmVzdWx0IG9mICR7ZmlsZVBhdGh9IHdpdGggbm9uLWZpbmFsIE1JTUUgdHlwZSAke3Jlc3VsdC5taW1lVHlwZX0sIGlucHV0IHdhcyAke2lucHV0TWltZVR5cGV9YCk7XHJcblxyXG4gICAgICBoYXNoSW5mbyA9IF8uYXNzaWduKHsgc291cmNlQ29kZTogcmVzdWx0LmNvZGUsIG1pbWVUeXBlOiByZXN1bHQubWltZVR5cGUgfSwgaGFzaEluZm8pO1xyXG4gICAgICBjb21waWxlciA9IHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVtyZXN1bHQubWltZVR5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xyXG5cclxuICAgICAgaWYgKCFjb21waWxlcikge1xyXG4gICAgICAgIGQoYFJlY3Vyc2l2ZSBjb21waWxlIGZhaWxlZCAtIGludGVybWVkaWF0ZSByZXN1bHQ6ICR7SlNPTi5zdHJpbmdpZnkocmVzdWx0KX1gKTtcclxuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxpbmcgJHtmaWxlUGF0aH0gcmVzdWx0ZWQgaW4gYSBNSU1FIHR5cGUgb2YgJHtyZXN1bHQubWltZVR5cGV9LCB3aGljaCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGVgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29tcGlsZVVuY2FjaGVkKFxyXG4gICAgICAgIGAke2ZpbGVQYXRofS4ke21pbWVUeXBlcy5leHRlbnNpb24ocmVzdWx0Lm1pbWVUeXBlIHx8ICd0eHQnKX1gLCBcclxuICAgICAgICBoYXNoSW5mbywgY29tcGlsZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvKiogIFxyXG4gICAqIFByZS1jYWNoZXMgYW4gZW50aXJlIGRpcmVjdG9yeSBvZiBmaWxlcyByZWN1cnNpdmVseS4gVXN1YWxseSB1c2VkIGZvciBcclxuICAgKiBidWlsZGluZyBjdXN0b20gY29tcGlsZXIgdG9vbGluZy5cclxuICAgKiAgICBcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3REaXJlY3RvcnkgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IHRvIGNvbXBpbGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBzaG91bGRDb21waWxlIChvcHRpb25hbCkgIEEgRnVuY3Rpb24gd2hpY2ggYWxsb3dzIHRoZSBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZXIgdG8gZGlzYWJsZSBjb21waWxpbmcgY2VydGFpbiBmaWxlcy5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCB0YWtlcyBhIGZ1bGx5LXF1YWxpZmllZCBwYXRoIHRvIGEgZmlsZSxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc2hvdWxkIHJldHVybiBhIEJvb2xlYW4uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgQ29tcGxldGlvbi5cclxuICAgKi8gICBcclxuICBhc3luYyBjb21waWxlQWxsKHJvb3REaXJlY3RvcnksIHNob3VsZENvbXBpbGU9bnVsbCkge1xyXG4gICAgbGV0IHNob3VsZCA9IHNob3VsZENvbXBpbGUgfHwgZnVuY3Rpb24oKSB7cmV0dXJuIHRydWU7fTtcclxuXHJcbiAgICBhd2FpdCBmb3JBbGxGaWxlcyhyb290RGlyZWN0b3J5LCAoZikgPT4ge1xyXG4gICAgICBpZiAoIXNob3VsZChmKSkgcmV0dXJuO1xyXG5cclxuICAgICAgZChgQ29tcGlsaW5nICR7Zn1gKTtcclxuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZShmLCB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8qXHJcbiAgICogU3luYyBNZXRob2RzXHJcbiAgICovXHJcbiAgIFxyXG4gIGNvbXBpbGVTeW5jKGZpbGVQYXRoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMucmVhZE9ubHlNb2RlID8gdGhpcy5jb21waWxlUmVhZE9ubHlTeW5jKGZpbGVQYXRoKSA6IHRoaXMuZnVsbENvbXBpbGVTeW5jKGZpbGVQYXRoKSk7XHJcbiAgfVxyXG4gIFxyXG4gIHN0YXRpYyBjcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uU3luYyhyb290Q2FjaGVEaXIsIGFwcFJvb3QsIGZhbGxiYWNrQ29tcGlsZXI9bnVsbCkge1xyXG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbihyb290Q2FjaGVEaXIsICdjb21waWxlci1pbmZvLmpzb24uZ3onKTtcclxuICAgIGxldCBidWYgPSBmcy5yZWFkRmlsZVN5bmModGFyZ2V0KTtcclxuICAgIGxldCBpbmZvID0gSlNPTi5wYXJzZSh6bGliLmd1bnppcFN5bmMoYnVmKSk7XHJcbiAgICBcclxuICAgIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShpbmZvLmZpbGVDaGFuZ2VDYWNoZSwgYXBwUm9vdCwgdHJ1ZSk7XHJcbiAgICBcclxuICAgIGxldCBjb21waWxlcnMgPSBfLnJlZHVjZShPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycyksIChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xyXG4gICAgICBhY2NbeF0gPSBuZXcgUmVhZE9ubHlDb21waWxlcihjdXIubmFtZSwgY3VyLmNvbXBpbGVyVmVyc2lvbiwgY3VyLmNvbXBpbGVyT3B0aW9ucywgY3VyLmlucHV0TWltZVR5cGVzKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcbiAgICBcclxuICAgIHJldHVybiBuZXcgQ29tcGlsZXJIb3N0KHJvb3RDYWNoZURpciwgY29tcGlsZXJzLCBmaWxlQ2hhbmdlQ2FjaGUsIHRydWUsIGZhbGxiYWNrQ29tcGlsZXIpO1xyXG4gIH1cclxuICBcclxuICBzdGF0aWMgY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgY29tcGlsZXJzQnlNaW1lVHlwZSwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XHJcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyh0YXJnZXQpO1xyXG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKHpsaWIuZ3VuemlwU3luYyhidWYpKTtcclxuICAgIFxyXG4gICAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGluZm8uZmlsZUNoYW5nZUNhY2hlLCBhcHBSb290LCBmYWxzZSk7XHJcbiAgICBcclxuICAgIF8uZWFjaChPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycyksICh4KSA9PiB7XHJcbiAgICAgIGxldCBjdXIgPSBpbmZvLmNvbXBpbGVyc1t4XTtcclxuICAgICAgY29tcGlsZXJzQnlNaW1lVHlwZVt4XS5jb21waWxlck9wdGlvbnMgPSBjdXIuY29tcGlsZXJPcHRpb25zO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBuZXcgQ29tcGlsZXJIb3N0KHJvb3RDYWNoZURpciwgY29tcGlsZXJzQnlNaW1lVHlwZSwgZmlsZUNoYW5nZUNhY2hlLCBmYWxzZSwgZmFsbGJhY2tDb21waWxlcik7XHJcbiAgfVxyXG4gICBcclxuICBzYXZlQ29uZmlndXJhdGlvblN5bmMoKSB7XHJcbiAgICBsZXQgc2VyaWFsaXplZENvbXBpbGVyT3B0cyA9IF8ucmVkdWNlKE9iamVjdC5rZXlzKHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZSksIChhY2MsIHgpID0+IHtcclxuICAgICAgbGV0IGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3hdO1xyXG4gICAgICBsZXQgS2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcGlsZXIpLmNvbnN0cnVjdG9yO1xyXG4gICAgICBcclxuICAgICAgbGV0IHZhbCA9IHtcclxuICAgICAgICBuYW1lOiBLbGFzcy5uYW1lLFxyXG4gICAgICAgIGlucHV0TWltZVR5cGVzOiBLbGFzcy5nZXRJbnB1dE1pbWVUeXBlcygpLFxyXG4gICAgICAgIGNvbXBpbGVyT3B0aW9uczogY29tcGlsZXIuY29tcGlsZXJPcHRpb25zLFxyXG4gICAgICAgIGNvbXBpbGVyVmVyc2lvbjogY29tcGlsZXIuZ2V0Q29tcGlsZXJWZXJzaW9uKClcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIGFjY1t4XSA9IHZhbDtcclxuICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9KTtcclxuICAgIFxyXG4gICAgbGV0IGluZm8gPSB7XHJcbiAgICAgIGZpbGVDaGFuZ2VDYWNoZTogdGhpcy5maWxlQ2hhbmdlQ2FjaGUuZ2V0U2F2ZWREYXRhKCksXHJcbiAgICAgIGNvbXBpbGVyczogc2VyaWFsaXplZENvbXBpbGVyT3B0c1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLnJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xyXG4gICAgbGV0IGJ1ZiA9IHpsaWIuZ3ppcFN5bmMobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShpbmZvKSkpO1xyXG4gICAgZnMud3JpdGVGaWxlU3luYyh0YXJnZXQsIGJ1Zik7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbXBpbGVSZWFkT25seVN5bmMoZmlsZVBhdGgpIHtcclxuICAgIC8vIFdlIGd1YXJhbnRlZSB0aGF0IG5vZGVfbW9kdWxlcyBhcmUgYWx3YXlzIHNoaXBwZWQgZGlyZWN0bHlcclxuICAgIGxldCB0eXBlID0gbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCk7XHJcbiAgICBpZiAoRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpKSB7XHJcbiAgICAgIHJldHVybiB7IFxyXG4gICAgICAgIG1pbWVUeXBlOiB0eXBlIHx8ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcclxuICAgICAgICBjb2RlOiBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4JykgXHJcbiAgICAgIH07ICAgIFxyXG4gICAgfSAgXHJcblxyXG4gICAgbGV0IGhhc2hJbmZvID0gdGhpcy5maWxlQ2hhbmdlQ2FjaGUuZ2V0SGFzaEZvclBhdGhTeW5jKGZpbGVQYXRoKTtcclxuICAgIFxyXG4gICAgLy8gV2UgZ3VhcmFudGVlIHRoYXQgbm9kZV9tb2R1bGVzIGFyZSBhbHdheXMgc2hpcHBlZCBkaXJlY3RseVxyXG4gICAgaWYgKGhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcykge1xyXG4gICAgICByZXR1cm4geyBcclxuICAgICAgICBtaW1lVHlwZTogdHlwZSwgXHJcbiAgICAgICAgY29kZTogaGFzaEluZm8uc291cmNlQ29kZSB8fCBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4JykgXHJcbiAgICAgIH07ICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8vIE5COiBIZXJlLCB3ZSdyZSBiYXNpY2FsbHkgb25seSB1c2luZyB0aGUgY29tcGlsZXIgaGVyZSB0byBmaW5kXHJcbiAgICAvLyB0aGUgYXBwcm9wcmlhdGUgQ29tcGlsZUNhY2hlXHJcbiAgICBsZXQgY29tcGlsZXIgPSBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pID9cclxuICAgICAgdGhpcy5nZXRQYXNzdGhyb3VnaENvbXBpbGVyKCkgOlxyXG4gICAgICB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbdHlwZSB8fCAnX19sb2xub3RoZXJlJ107XHJcblxyXG4gICAgaWYgKCFjb21waWxlcikgeyBcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XHJcblxyXG4gICAgICBsZXQgeyBjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZSB9ID0gY29tcGlsZXIuZ2V0U3luYyhmaWxlUGF0aCk7XHJcbiAgICAgIHJldHVybiB7IGNvZGU6IGNvZGUgfHwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xyXG4gICAgbGV0IHtjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZX0gPSBjYWNoZS5nZXRTeW5jKGZpbGVQYXRoKTtcclxuXHJcbiAgICBjb2RlID0gY29kZSB8fCBiaW5hcnlEYXRhO1xyXG4gICAgaWYgKCFjb2RlIHx8ICFtaW1lVHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFza2VkIHRvIGNvbXBpbGUgJHtmaWxlUGF0aH0gaW4gcHJvZHVjdGlvbiwgaXMgdGhpcyBmaWxlIG5vdCBwcmVjb21waWxlZD9gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZSB9O1xyXG4gIH1cclxuXHJcbiAgZnVsbENvbXBpbGVTeW5jKGZpbGVQYXRoKSB7XHJcbiAgICBkKGBDb21waWxpbmcgJHtmaWxlUGF0aH1gKTtcclxuXHJcbiAgICBsZXQgaGFzaEluZm8gPSB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aFN5bmMoZmlsZVBhdGgpO1xyXG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuICAgIFxyXG4gICAgaWYgKGhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcykge1xyXG4gICAgICBsZXQgY29kZSA9IGhhc2hJbmZvLnNvdXJjZUNvZGUgfHwgZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xyXG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogdHlwZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjb21waWxlciA9IENvbXBpbGVySG9zdC5zaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbykgP1xyXG4gICAgICB0aGlzLmdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKSA6XHJcbiAgICAgIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt0eXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcclxuXHJcbiAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgIGQoYEZhbGxpbmcgYmFjayB0byBwYXNzdGhyb3VnaCBjb21waWxlciBmb3IgJHtmaWxlUGF0aH1gKTtcclxuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb21waWxlcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgYSBjb21waWxlciBmb3IgJHtmaWxlUGF0aH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xyXG4gICAgcmV0dXJuIGNhY2hlLmdldE9yRmV0Y2hTeW5jKFxyXG4gICAgICBmaWxlUGF0aCxcclxuICAgICAgKGZpbGVQYXRoLCBoYXNoSW5mbykgPT4gdGhpcy5jb21waWxlVW5jYWNoZWRTeW5jKGZpbGVQYXRoLCBoYXNoSW5mbywgY29tcGlsZXIpKTtcclxuICB9XHJcblxyXG4gIGNvbXBpbGVVbmNhY2hlZFN5bmMoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikge1xyXG4gICAgbGV0IGlucHV0TWltZVR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcclxuICAgIFxyXG4gICAgaWYgKGhhc2hJbmZvLmlzRmlsZUJpbmFyeSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGJpbmFyeURhdGE6IGhhc2hJbmZvLmJpbmFyeURhdGEgfHwgZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoKSxcclxuICAgICAgICBtaW1lVHlwZTogaW5wdXRNaW1lVHlwZSxcclxuICAgICAgICBkZXBlbmRlbnRGaWxlczogW11cclxuICAgICAgfTtcclxuICAgIH1cclxuICBcclxuICAgIGxldCBjdHggPSB7fTtcclxuICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XHJcblxyXG4gICAgaWYgKCEoY29tcGlsZXIuc2hvdWxkQ29tcGlsZUZpbGVTeW5jKGNvZGUsIGN0eCkpKSB7XHJcbiAgICAgIGQoYENvbXBpbGVyIHJldHVybmVkIGZhbHNlIGZvciBzaG91bGRDb21waWxlRmlsZTogJHtmaWxlUGF0aH1gKTtcclxuICAgICAgcmV0dXJuIHsgY29kZSwgbWltZVR5cGU6IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpLCBkZXBlbmRlbnRGaWxlczogW10gfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZGVwZW5kZW50RmlsZXMgPSBjb21waWxlci5kZXRlcm1pbmVEZXBlbmRlbnRGaWxlc1N5bmMoY29kZSwgZmlsZVBhdGgsIGN0eCk7XHJcblxyXG4gICAgbGV0IHJlc3VsdCA9IGNvbXBpbGVyLmNvbXBpbGVTeW5jKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xyXG5cclxuICAgIGxldCBzaG91bGRJbmxpbmVIdG1saWZ5ID0gXHJcbiAgICAgIGlucHV0TWltZVR5cGUgIT09ICd0ZXh0L2h0bWwnICYmXHJcbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvaHRtbCc7XHJcbiAgICAgIFxyXG4gICAgbGV0IGlzUGFzc3Rocm91Z2ggPSBcclxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9wbGFpbicgfHwgXHJcbiAgICAgICFyZXN1bHQubWltZVR5cGUgfHwgXHJcbiAgICAgIENvbXBpbGVySG9zdC5zaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbyk7XHJcbiAgICAgIFxyXG4gICAgaWYgKChmaW5hbEZvcm1zW3Jlc3VsdC5taW1lVHlwZV0gJiYgIXNob3VsZElubGluZUh0bWxpZnkpIHx8IGlzUGFzc3Rocm91Z2gpIHtcclxuICAgICAgLy8gR290IHNvbWV0aGluZyB3ZSBjYW4gdXNlIGluLWJyb3dzZXIsIGxldCdzIHJldHVybiBpdFxyXG4gICAgICByZXR1cm4gXy5hc3NpZ24ocmVzdWx0LCB7ZGVwZW5kZW50RmlsZXN9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGQoYFJlY3Vyc2l2ZWx5IGNvbXBpbGluZyByZXN1bHQgb2YgJHtmaWxlUGF0aH0gd2l0aCBub24tZmluYWwgTUlNRSB0eXBlICR7cmVzdWx0Lm1pbWVUeXBlfSwgaW5wdXQgd2FzICR7aW5wdXRNaW1lVHlwZX1gKTtcclxuXHJcbiAgICAgIGhhc2hJbmZvID0gXy5hc3NpZ24oeyBzb3VyY2VDb2RlOiByZXN1bHQuY29kZSwgbWltZVR5cGU6IHJlc3VsdC5taW1lVHlwZSB9LCBoYXNoSW5mbyk7XHJcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3Jlc3VsdC5taW1lVHlwZSB8fCAnX19sb2xub3RoZXJlJ107XHJcblxyXG4gICAgICBpZiAoIWNvbXBpbGVyKSB7XHJcbiAgICAgICAgZChgUmVjdXJzaXZlIGNvbXBpbGUgZmFpbGVkIC0gaW50ZXJtZWRpYXRlIHJlc3VsdDogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGluZyAke2ZpbGVQYXRofSByZXN1bHRlZCBpbiBhIE1JTUUgdHlwZSBvZiAke3Jlc3VsdC5taW1lVHlwZX0sIHdoaWNoIHdlIGRvbid0IGtub3cgaG93IHRvIGhhbmRsZWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlVW5jYWNoZWRTeW5jKFxyXG4gICAgICAgIGAke2ZpbGVQYXRofS4ke21pbWVUeXBlcy5leHRlbnNpb24ocmVzdWx0Lm1pbWVUeXBlIHx8ICd0eHQnKX1gLCBcclxuICAgICAgICBoYXNoSW5mbywgY29tcGlsZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29tcGlsZUFsbFN5bmMocm9vdERpcmVjdG9yeSwgc2hvdWxkQ29tcGlsZT1udWxsKSB7XHJcbiAgICBsZXQgc2hvdWxkID0gc2hvdWxkQ29tcGlsZSB8fCBmdW5jdGlvbigpIHtyZXR1cm4gdHJ1ZTt9O1xyXG5cclxuICAgIGZvckFsbEZpbGVzU3luYyhyb290RGlyZWN0b3J5LCAoZikgPT4ge1xyXG4gICAgICBpZiAoIXNob3VsZChmKSkgcmV0dXJuO1xyXG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlU3luYyhmLCB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8qXHJcbiAgICogT3RoZXIgc3R1ZmZcclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHBhc3N0aHJvdWdoIGNvbXBpbGVyIFxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi8gICBcclxuICBnZXRQYXNzdGhyb3VnaENvbXBpbGVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVsndGV4dC9wbGFpbiddO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgZXZlbiB0cnkgdG8gY29tcGlsZSB0aGUgY29udGVudC4gTm90ZSB0aGF0IGluXHJcbiAgICogc29tZSBjYXNlcywgY29udGVudCB3aWxsIHN0aWxsIGJlIGluIGNhY2hlIGV2ZW4gaWYgdGhpcyByZXR1cm5zIHRydWUsIGFuZFxyXG4gICAqIGluIG90aGVyIGNhc2VzIChpc0luTm9kZU1vZHVsZXMpLCB3ZSdsbCBrbm93IGV4cGxpY2l0bHkgdG8gbm90IGV2ZW4gYm90aGVyXHJcbiAgICogbG9va2luZyBpbiB0aGUgY2FjaGUuXHJcbiAgICogICAgXHJcbiAgICogQHByaXZhdGVcclxuICAgKi8gICBcclxuICBzdGF0aWMgc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pIHtcclxuICAgIHJldHVybiBoYXNoSW5mby5pc01pbmlmaWVkIHx8IGhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcyB8fCBoYXNoSW5mby5oYXNTb3VyY2VNYXAgfHwgaGFzaEluZm8uaXNGaWxlQmluYXJ5O1xyXG4gIH1cclxufVxyXG4iXX0=