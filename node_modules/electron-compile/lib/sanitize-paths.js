'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sanitizeFilePath;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _lruCache = require('lru-cache');

var _lruCache2 = _interopRequireDefault(_lruCache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var d = require('debug')('electron-compile:sanitize-paths');
var realpathCache = (0, _lruCache2.default)({ max: 32 });

function cachedRealpath(p) {
  var ret = realpathCache.get(p);
  if (ret) return ret;

  ret = _fs2.default.realpathSync(p);
  d('Cache miss for cachedRealpath: \'' + p + '\' => \'' + ret + '\'');

  realpathCache.set(p, ret);
  return ret;
}

/**
 * Electron will sometimes hand us paths that don't match the platform if they
 * were derived from a URL (i.e. 'C:/Users/Paul/...'), whereas the cache will have
 * saved paths with backslashes.
 *
 * @private
 */
function sanitizeFilePath(file) {
  if (!file) return file;

  // NB: Some people add symlinks into system directories. node.js will internally
  // call realpath on paths that it finds, which will break our cache resolution.
  // We need to catch this scenario and fix it up. The tricky part is, some parts
  // of Electron will give us the pre-resolved paths, and others will give us the
  // post-resolved one. We need to handle both.

  var realFile = null;
  var parts = file.split(/[\\\/]app.asar[\\\/]/);
  if (!parts[1]) {
    // Not using an ASAR archive
    realFile = cachedRealpath(file);
  } else {
    // We do all this silliness to work around
    // https://github.com/atom/electron/issues/4610
    realFile = cachedRealpath(parts[0]) + '/app.asar/' + parts[1];
  }

  return realFile.replace(/[\\\/]/g, '/');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zYW5pdGl6ZS1wYXRocy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztrQkF3QndCLGdCOztBQXhCeEI7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBTSxJQUFJLFFBQVEsT0FBUixFQUFpQixpQ0FBakIsQ0FBVjtBQUNBLElBQU0sZ0JBQWdCLHdCQUFTLEVBQUUsS0FBSyxFQUFQLEVBQVQsQ0FBdEI7O0FBRUEsU0FBUyxjQUFULENBQXdCLENBQXhCLEVBQTJCO0FBQ3pCLE1BQUksTUFBTSxjQUFjLEdBQWQsQ0FBa0IsQ0FBbEIsQ0FBVjtBQUNBLE1BQUksR0FBSixFQUFTLE9BQU8sR0FBUDs7QUFFVCxRQUFNLGFBQUcsWUFBSCxDQUFnQixDQUFoQixDQUFOO0FBQ0EsMENBQXFDLENBQXJDLGdCQUErQyxHQUEvQzs7QUFFQSxnQkFBYyxHQUFkLENBQWtCLENBQWxCLEVBQXFCLEdBQXJCO0FBQ0EsU0FBTyxHQUFQO0FBQ0Q7Ozs7Ozs7OztBQVNjLFNBQVMsZ0JBQVQsQ0FBMEIsSUFBMUIsRUFBZ0M7QUFDN0MsTUFBSSxDQUFDLElBQUwsRUFBVyxPQUFPLElBQVA7Ozs7Ozs7O0FBUVgsTUFBSSxXQUFXLElBQWY7QUFDQSxNQUFJLFFBQVEsS0FBSyxLQUFMLENBQVcsc0JBQVgsQ0FBWjtBQUNBLE1BQUksQ0FBQyxNQUFNLENBQU4sQ0FBTCxFQUFlOztBQUViLGVBQVcsZUFBZSxJQUFmLENBQVg7QUFDRCxHQUhELE1BR087OztBQUdMLGVBQWMsZUFBZSxNQUFNLENBQU4sQ0FBZixDQUFkLGtCQUFtRCxNQUFNLENBQU4sQ0FBbkQ7QUFDRDs7QUFFRCxTQUFPLFNBQVMsT0FBVCxDQUFpQixTQUFqQixFQUE0QixHQUE1QixDQUFQO0FBQ0QiLCJmaWxlIjoic2FuaXRpemUtcGF0aHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgTFJVQ2FjaGUgZnJvbSAnbHJ1LWNhY2hlJztcclxuXHJcbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOnNhbml0aXplLXBhdGhzJyk7XHJcbmNvbnN0IHJlYWxwYXRoQ2FjaGUgPSBMUlVDYWNoZSh7IG1heDogMzIgfSk7XHJcblxyXG5mdW5jdGlvbiBjYWNoZWRSZWFscGF0aChwKSB7XHJcbiAgbGV0IHJldCA9IHJlYWxwYXRoQ2FjaGUuZ2V0KHApO1xyXG4gIGlmIChyZXQpIHJldHVybiByZXQ7XHJcblxyXG4gIHJldCA9IGZzLnJlYWxwYXRoU3luYyhwKTtcclxuICBkKGBDYWNoZSBtaXNzIGZvciBjYWNoZWRSZWFscGF0aDogJyR7cH0nID0+ICcke3JldH0nYCk7XHJcblxyXG4gIHJlYWxwYXRoQ2FjaGUuc2V0KHAsIHJldCk7XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVsZWN0cm9uIHdpbGwgc29tZXRpbWVzIGhhbmQgdXMgcGF0aHMgdGhhdCBkb24ndCBtYXRjaCB0aGUgcGxhdGZvcm0gaWYgdGhleVxyXG4gKiB3ZXJlIGRlcml2ZWQgZnJvbSBhIFVSTCAoaS5lLiAnQzovVXNlcnMvUGF1bC8uLi4nKSwgd2hlcmVhcyB0aGUgY2FjaGUgd2lsbCBoYXZlXHJcbiAqIHNhdmVkIHBhdGhzIHdpdGggYmFja3NsYXNoZXMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzYW5pdGl6ZUZpbGVQYXRoKGZpbGUpIHtcclxuICBpZiAoIWZpbGUpIHJldHVybiBmaWxlO1xyXG5cclxuICAvLyBOQjogU29tZSBwZW9wbGUgYWRkIHN5bWxpbmtzIGludG8gc3lzdGVtIGRpcmVjdG9yaWVzLiBub2RlLmpzIHdpbGwgaW50ZXJuYWxseVxyXG4gIC8vIGNhbGwgcmVhbHBhdGggb24gcGF0aHMgdGhhdCBpdCBmaW5kcywgd2hpY2ggd2lsbCBicmVhayBvdXIgY2FjaGUgcmVzb2x1dGlvbi5cclxuICAvLyBXZSBuZWVkIHRvIGNhdGNoIHRoaXMgc2NlbmFyaW8gYW5kIGZpeCBpdCB1cC4gVGhlIHRyaWNreSBwYXJ0IGlzLCBzb21lIHBhcnRzXHJcbiAgLy8gb2YgRWxlY3Ryb24gd2lsbCBnaXZlIHVzIHRoZSBwcmUtcmVzb2x2ZWQgcGF0aHMsIGFuZCBvdGhlcnMgd2lsbCBnaXZlIHVzIHRoZVxyXG4gIC8vIHBvc3QtcmVzb2x2ZWQgb25lLiBXZSBuZWVkIHRvIGhhbmRsZSBib3RoLlxyXG5cclxuICBsZXQgcmVhbEZpbGUgPSBudWxsO1xyXG4gIGxldCBwYXJ0cyA9IGZpbGUuc3BsaXQoL1tcXFxcXFwvXWFwcC5hc2FyW1xcXFxcXC9dLyk7XHJcbiAgaWYgKCFwYXJ0c1sxXSkge1xyXG4gICAgLy8gTm90IHVzaW5nIGFuIEFTQVIgYXJjaGl2ZVxyXG4gICAgcmVhbEZpbGUgPSBjYWNoZWRSZWFscGF0aChmaWxlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gV2UgZG8gYWxsIHRoaXMgc2lsbGluZXNzIHRvIHdvcmsgYXJvdW5kXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXRvbS9lbGVjdHJvbi9pc3N1ZXMvNDYxMFxyXG4gICAgcmVhbEZpbGUgPSBgJHtjYWNoZWRSZWFscGF0aChwYXJ0c1swXSl9L2FwcC5hc2FyLyR7cGFydHNbMV19YDtcclxuICB9XHJcblxyXG4gIHJldHVybiByZWFsRmlsZS5yZXBsYWNlKC9bXFxcXFxcL10vZywgJy8nKTtcclxufVxyXG4iXX0=